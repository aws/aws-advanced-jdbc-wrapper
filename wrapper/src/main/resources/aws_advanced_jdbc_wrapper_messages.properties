#
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

AbstractMonitor.interruptedWhileTerminating=Interrupted while awaiting termination of monitor ''{0}''. The monitor will be forcefully shut down.
AbstractMonitor.monitorTerminationTimeout=Timed out after waiting {0} seconds for monitor ''{1}'' to terminate gracefully. The monitor will be forcefully shut down.
AbstractMonitor.startingMonitor=Starting monitor: ''{0}''.
AbstractMonitor.stoppingMonitor=Stopping monitor: ''{0}''.
AbstractMonitor.unexpectedError=A monitor encountered an unexpected exception. Monitor: ''{0}''. Exception: ''{1}''.

AdfsCredentialsProviderFactory.failedLogin=Failed login. Could not obtain SAML Assertion from ADFS SignOn Page POST response: \n''{0}''
AdfsCredentialsProviderFactory.invalidHttpsUrl=Invalid HTTPS URL: ''{0}''
AdfsCredentialsProviderFactory.signOnPagePostActionUrl=ADFS SignOn Action URL: ''{0}''
AdfsCredentialsProviderFactory.signOnPagePostActionRequestFailed=ADFS SignOn Page POST action failed with HTTP status ''{0}'', reason phrase ''{1}'', and response ''{2}''
AdfsCredentialsProviderFactory.signOnPageRequestFailed=ADFS SignOn Page Request Failed with HTTP status ''{0}'', reason phrase ''{1}'', and response ''{2}''
AdfsCredentialsProviderFactory.signOnPageUrl=ADFS SignOn URL: ''{0}''

AuroraPgDialect.auroraUtils=auroraUtils: {0}

AuthenticationToken.useCachedToken=Use cached authentication token = ''{0}''
AuthenticationToken.generatedNewToken=Generated new authentication token = ''{0}''
AuthenticationToken.javaSdkNotInClasspath=Required dependency 'AWS Java SDK RDS v2.x' is not on the classpath.
AuthenticationToken.rdsSdkNotInClasspath=Required dependency 'AWS Java SDK RDS v2.x' is not on the classpath. Only the full RDS SDK is supported when using Global databases.

RdsHostListProvider.clusterInstanceHostPatternNotSupportedForRDSProxy=An RDS Proxy url can''t be used as the 'clusterInstanceHostPattern' configuration setting.
RdsHostListProvider.clusterInstanceHostPatternNotSupportedForRdsCustom=A custom RDS url can''t be used as the 'clusterInstanceHostPattern' configuration setting.
RdsHostListProvider.invalidPattern=Invalid value for the 'clusterInstanceHostPattern' configuration setting - the host pattern must contain a '?' character as a placeholder for the DB instance identifiers of the instances in the cluster.
RdsHostListProvider.parsedListEmpty=Can''t parse connection string: ''{0}''
RdsHostListProvider.errorIdentifyConnection=An error occurred while obtaining the connection's host ID.

RdsPgDialect.rdsToolsAuroraUtils=rdsTools: {0}, auroraUtils: {1}

AwsSdk.unsupportedRegion=Unsupported AWS region ''{0}''. For supported regions please read https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html

AwsSecretsManagerConnectionPlugin.endpointOverrideMisconfigured=The provided endpoint is invalid and could not be used to create a URI: `{0}`.
AwsSecretsManagerConnectionPlugin.endpointOverrideInvalidConnection=A connection to the provided endpoint could not be established: `{0}`.
AwsSecretsManagerConnectionPlugin.javaSdkNotInClasspath=Required dependency 'AWS Java SDK for AWS Secrets Manager' is not on the classpath.
AwsSecretsManagerConnectionPlugin.invalidSecretFormat=Unable to fetch database credentials with the given username and password. Please review the values specified in secretsManagerSecretUsernameProperty (`{0}`) and secretsManagerSecretPasswordProperty (`{1}`) and ensure they match the Secrets Manager JSON format.
AwsSecretsManagerConnectionPlugin.jacksonDatabindNotInClasspath=Required dependency 'Jackson Databind' is not on the classpath.
AwsSecretsManagerConnectionPlugin.failedToFetchDbCredentials=Was not able to either fetch or read the database credentials from AWS Secrets Manager. Ensure the correct secretId and region properties have been provided.
AwsSecretsManagerConnectionPlugin.missingRequiredConfigParameter=Configuration parameter ''{0}'' is required.
AwsSecretsManagerConnectionPlugin.unhandledException=Unhandled exception: ''{0}''

AwsWrapperDataSource.missingJdbcProtocol=Missing JDBC protocol. Could not construct URL.
AwsWrapperDataSource.missingTarget=JDBC url or Server name is required.
AwsWrapperDataSource.configurationProfileNotFound=Configuration profile ''{0}'' not found.

ClusterAwareReaderFailoverHandler.interruptedThread=Thread was interrupted.
ClusterAwareReaderFailoverHandler.attemptingReaderConnection=Trying to connect to host: ''{0}'', with properties ''{1}''
ClusterAwareReaderFailoverHandler.readerRequired=Connected to host ''{0}'' but it has a host role of ''{1}'' and does not meet the strict-reader requirement. The connection will be closed.
ClusterAwareReaderFailoverHandler.errorGettingHostRole=An error occurred while trying to determine the role of the host candidate: {0}
ClusterAwareReaderFailoverHandler.successfulReaderConnection=Connected to host: ''{0}''
ClusterAwareReaderFailoverHandler.failedReaderConnection=Failed to connect to host: ''{0}''
ClusterAwareReaderFailoverHandler.invalidTopology=''{0}'' was called with an invalid (null or empty) topology.
ClusterAwareReaderFailoverHandler.timeout=Reader failover timed out after {0}ms.

ClusterAwareWriterFailoverHandler.interruptedThread=Thread was interrupted.
ClusterAwareWriterFailoverHandler.successfullyReconnectedToWriterInstance=Successfully re-connected to the current writer instance: ''{0}''
ClusterAwareWriterFailoverHandler.failedToConnectToWriterInstance=Failed to connect to the writer instance.
ClusterAwareWriterFailoverHandler.successfullyConnectedToNewWriterInstance=Successfully connected to the new writer instance: ''{0}''
ClusterAwareWriterFailoverHandler.successfulConnectionInvalidTopology={0} successfully established a connection but doesn't contain a valid topology.
ClusterAwareWriterFailoverHandler.taskAAttemptReconnectToWriterInstance=[TaskA] Attempting to re-connect to the current writer instance: ''{0}'', with properties ''{1}''
ClusterAwareWriterFailoverHandler.failoverCalledWithInvalidTopology=Failover was called with an invalid (null or empty) topology.
ClusterAwareWriterFailoverHandler.taskAFinished=[TaskA] Finished
ClusterAwareWriterFailoverHandler.taskBAttemptConnectionToNewWriterInstance=[TaskB] Attempting to connect to a new writer instance, with properties ''{0}''
ClusterAwareWriterFailoverHandler.taskBFinished=[TaskB] Finished
ClusterAwareWriterFailoverHandler.taskBConnectedToReader=[TaskB] Connected to reader: ''{0}''
ClusterAwareWriterFailoverHandler.taskBFailedToConnectToAnyReader=[TaskB] Failed to connect to any reader.
ClusterAwareWriterFailoverHandler.taskBAttemptConnectionToNewWriter=[TaskB] Trying to connect to a new writer: ''{0}''
ClusterAwareWriterFailoverHandler.taskBEncounteredException=[TaskB] encountered an exception: {0}
ClusterAwareWriterFailoverHandler.taskAEncounteredException=[TaskA] encountered an exception: {0}
ClusterAwareWriterFailoverHandler.standaloneNode=[TaskB] Host {0} is not yet connected to a cluster. The cluster is still being reconfigured.
ClusterAwareWriterFailoverHandler.alreadyWriter=Current reader connection is actually a new writer connection.

ConnectionStringHostListProvider.parsedListEmpty=Can''t parse connection string: ''{0}''.
ConnectionStringHostListProvider.unsupportedIdentifyConnection=ConnectionStringHostListProvider does not support identifyConnection.

ConnectionPluginManager.releaseResources=Releasing resources.
ConnectionPluginManager.unknownPluginCode=Unknown plugin code: ''{0}''.
ConnectionPluginManager.unableToLoadPlugin=Unable to load connection plugin factory: ''{0}''.
ConnectionPluginManager.invokedAgainstOldConnection=The internal connection has changed since ''{0}'' was created. This is likely due to failover or read-write splitting functionality. To ensure you are using the updated connection, please re-create Statement and ResultSet objects after failover and/or calling setReadOnly.

ConnectionProvider.noConnection=The target driver did not return a connection.
ConnectionProvider.unsupportedHostSpecSelectorStrategy=Unsupported host selection strategy ''{0}'' specified for this connection provider ''{1}''. Please visit the documentation for all supported strategies.

ConnectionUrlBuilder.missingJdbcProtocol=Missing JDBC protocol and/or host name. Could not construct URL.

ConnectionUrlParser.protocolNotFound=Url should contain a driver protocol. Protocol is not found in url: ''{0}''
ConnectionUrlParser.cantParseUrl=Can''t parse URL from ''{0}''.
ConnectionUrlParser.cantParseHost=Can''t parse host from ''{0}''.
ConnectionUrlParser.cantParseAwsRegion=Can''t parse AWS region from ''{0}''.

ConnectTimeConnectionPlugin.connectTime=Connected in {0} nanos.

ConnectionWrapper.unclosedConnectionInstantiated=Unclosed connection was instantiated at this point:
ConnectionWrapper.connectionNotOpen=Initial connection isn't open.
ConnectionWrapper.finalizingUnclosedConnection=Finalizing a connection that was never closed. Connection is opened from thread ''{0}''.

ConsoleConsumer.unexpectedOutputType=Unexpected outputType: ''{0}''.

CredentialsProviderFactory.failedToInitializeHttpClient=Failed to initialize HttpClient.
CredentialsProviderFactory.unsupportedIdp=Unsupported Identity Provider ''{0}''. Please visit to the documentation for supported Identity Providers.

CustomEndpointMonitorImpl.clearCache=Clearing info in the custom endpoint monitor info cache.
CustomEndpointMonitorImpl.detectedChangeInCustomEndpointInfo=Detected change in custom endpoint info for ''{0}'':\n{1}
CustomEndpointMonitorImpl.exception=Encountered an exception while monitoring custom endpoint ''{0}''.
CustomEndpointMonitorImpl.interrupted=Custom endpoint monitor for ''{0}'' was interrupted.
CustomEndpointMonitorImpl.startingMonitor=Starting custom endpoint monitor for ''{0}''.
CustomEndpointMonitorImpl.stoppedMonitor=Stopped custom endpoint monitor for ''{0}''.
CustomEndpointMonitorImpl.unexpectedNumberOfEndpoints=Unexpected number of custom endpoints with endpoint identifier ''{0}'' in region ''{1}''. Expected 1, but found {2}. Endpoints:\n{3}.

CustomEndpointPlugin.timedOutWaitingForCustomEndpointInfo=The custom endpoint plugin timed out after {0}ms while waiting for custom endpoint info for host ''{1}''.
CustomEndpointPlugin.connectionRequestToCustomEndpoint=Detected a connection request to a custom endpoint URL: ''{0}''.
CustomEndpointPlugin.errorParsingEndpointIdentifier=Unable to parse custom endpoint identifier from URL: ''{0}''.
CustomEndpointPlugin.interruptedThread=The custom endpoint plugin was interrupted while waiting for custom endpoint info for host ''{0}''.
CustomEndpointPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.
CustomEndpointPlugin.waitingForCustomEndpointInfo=Custom endpoint info for ''{0}'' was not found. Waiting {1}ms for the endpoint monitor to fetch info...

CustomEndpointPluginFactory.awsSdkNotInClasspath=Required dependency 'AWS Java SDK RDS v2.x' is not on the classpath.

DataCacheConnectionPlugin.queryResultsCached=[{0}] Query results will be cached: {1}

DefaultConnectionPlugin.executingMethod=Executing method: ''{0}''
DefaultConnectionPlugin.noHostsAvailable=The default connection plugin received an empty host list from the plugin service.
DefaultConnectionPlugin.unknownRoleRequested=A HostSpec with a role of HostRole.UNKNOWN was requested via getHostSpecByStrategy. The requested role must be either HostRole.WRITER or HostRole.READER

DialectManager.currentDialect=Current dialect: {0}, {1}, canUpdate: {2}

Driver.nullUrl=Url is null.
Driver.alreadyRegistered=Driver is already registered. It can only be registered once.
Driver.missingDriver=Can''t find the target driver for ''{0}''. Please ensure the target driver is in the classpath and is registered. Here is the list of registered drivers in the classpath: {1}
Driver.notRegistered=Driver is not registered (or it has not been registered using Driver.register() method).
Driver.urlParsingFailed=Url [{0}] parsing failed with error: [{1}]
Driver.configurationProfileNotFound=Configuration profile ''{0}'' not found.

DataSource.failedToSetProperty=Failed to set property ''{0}'' on target datasource ''{1}''.

ExecutionTimeConnectionPlugin.executionTime=Executed {0} in {1} nanos.

ExpirationCache.exceptionWhileRemovingEntry=An exception occurred while removing entry with key ''{0}'' and value ''{1}'': ''{2}''.

ExternallyManagedCache.extendExpirationOnNonExistingKey=A request was made to extend the expiration of the entry at key ''{0}'', but the key does not exist.

Failover.transactionResolutionUnknownError=Transaction resolution unknown. Please re-configure session state if required and try restarting the transaction.
Failover.connectionClosedExplicitly=Unable to failover, the connection has been explicitly closed.
Failover.connectionChangedError=The active SQL connection has changed due to a connection failure. Please re-configure session state if required.
Failover.exceptionConnectingToWriter=An exception occurred while trying to connect to the new writer ''{0}''.
Failover.failoverReaderTimeout=The reader failover process was not able to establish a connection before timing out.
Failover.failoverReaderUnableToRefreshHostList=The request to discover the new topology was unsuccessful.
Failover.noWriterHostAfterReconnecting=The writer failover process successfully reconnected, but no writer was found in the updated topology: {0}
Failover.nullReaderFailoverHandlerSupplier=The failover plugin was unable to create a reader failover handler because the supplier was unexpectedly null.
Failover.nullWriterFailoverHandlerSupplier=The failover plugin was unable to create a writer failover handler because the supplier was unexpectedly null.
Failover.parameterValue={0}={1}
Failover.unableToConnect=Unable to establish a SQL connection due to an unexpected error.
Failover.unableToConnectToWriter=Unable to establish SQL connection to the writer instance.
Failover.unableToConnectToReader=Unable to establish SQL connection to the reader instance.
Failover.unableToRefreshHostList=The request to discover the new topology timed out or was unsuccessful.
Failover.unexpectedReaderRole=The new writer was identified to be ''{0}'', but querying the instance for its role returned a role of {1}.
Failover.strictReaderUnknownHostRole=Unable to determine host role for ''{0}''. Since failover mode is set to STRICT_READER and the host may be a writer, it will not be selected for reader failover.
Failover.detectedException=Detected an exception while executing a command: {0}
Failover.failoverDisabled=Cluster-aware failover is disabled.
Failover.establishedConnection=Connected to: {0}
Failover.startWriterFailover=Starting writer failover procedure.
Failover.startReaderFailover=Starting reader failover procedure.
Failover.invalidNode=Node is no longer available in the topology: {0}
Failover.newWriterNotAllowed=The failover process identified the new writer but the host is not in the list of allowed hosts. New writer host: ''{0}''. Allowed hosts: {1}
Failover.noOperationsAfterConnectionClosed=No operations allowed after connection closed.
Failover.noWriterHost=Unable to find writer in updated host list.
Failover.readerCandidateNull=Unable to find reader in updated host list:
Failover.readerFailoverElapsed=Reader failover elapsed in {0} ms.
Failover.writerFailoverElapsed=Writer failover elapsed in {0} ms.
Failover.failedReaderConnection=[Reader Failover] Failed to connect to host: ''{0}''
Failover.errorSelectingReaderHost=An error occurred while attempting to select a reader host candidate: ''{0}''. Candidates:
Failover.skipFailoverOnInterruptedThread=Do not start failover since the current thread is interrupted.

FederatedAuthPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.

GlobalAuroraTopologyMonitor.cannotFindRegionTemplate=Cannot find cluster template for region {0}.

GlobalAuroraTopologyUtils.globalClusterInstanceHostPatternsRequired=Parameter 'globalClusterInstanceHostPatterns' is required for Aurora Global Database.
GlobalAuroraTopologyUtils.detectedGdbPatterns=Detected GDB instance template patterns:\n{0}

HostAvailabilityStrategy.invalidMaxRetries=Invalid value of {0} for configuration parameter `hostAvailabilityStrategyMaxRetries`. It must be an integer greater than 1.
HostAvailabilityStrategy.invalidInitialBackoffTime=Invalid value of {0}  for configuration parameter `hostAvailabilityStrategyInitialBackoffTime`. It must be an integer greater than 1.

HostMonitoringConnectionPlugin.activatedMonitoring=Executing method ''{0}'', monitoring is activated.
HostMonitoringConnectionPlugin.monitoringDeactivated=Monitoring deactivated for method ''{0}''.
HostMonitoringConnectionPlugin.unavailableNode=Node ''{0}'' is unavailable.
HostMonitoringConnectionPlugin.errorIdentifyingConnection=Error occurred while identifying connection: ''{0}''.
HostMonitoringConnectionPlugin.unableToIdentifyConnection=Unable to identify the given connection: ''{0}'', please ensure the correct host list provider is specified. The host list provider in use is: ''{1}''.

HostSelector.noHostsMatchingRole=No hosts were found matching the requested ''{0}'' role.
HostSelector.roundRobinInvalidHostWeightPairs=The provided host weight pairs have not been configured correctly. Please ensure the provided host weight pairs is a comma separated list of pairs, each pair in the format of <host>:<weight>. Weight values must be an integer greater than or equal to the default weight value of 1.
HostSelector.roundRobinInvalidDefaultWeight=The provided default weight value is not valid. Weight values must be an integer greater than or equal to the default weight value of 1.
HostSelector.weightedRandomInvalidHostWeightPairs=The provided host weight pairs have not been configured correctly. Please ensure the provided host weight pairs is a comma separated list of pairs, each pair in the format of <host>:<weight>. Weight values must be an integer greater than or equal to the default weight value of 1.
HostSelector.weightedRandomUnableToGetHost=Weighted Random strategy was unable to select a host.

IamAuthConnectionPlugin.unhandledException=Unhandled exception: ''{0}''
IamAuthConnectionPlugin.connectException=Error occurred while opening a connection: ''{0}''
IamAuthConnectionPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.

PartialPluginService.unexpectedMethodCall=Calling ''{0}()'' is not supported with this PluginService.

LimitlessConnectionPlugin.failedToConnectToHost=Failed to connect to host {0}.
LimitlessConnectionPlugin.unsupportedDialectOrDatabase=Unsupported dialect ''{0}'' encountered. Please ensure JDBC connection parameters are correct, and refer to the documentation to ensure that the connecting database is compatible with the Limitless Connection Plugin.
LimitlessConnectionPlugin.incompatibleWeightedRandomHostWeightPairsProperty=The Limitless Plugin is incompatible with the {0} property. The Limitless plugin uses a list of dynamic hosts and weights through the WeightedRandomHostSelector when choosing a host. Setting this property to a specific value will make the host list static.

LimitlessQueryHelper.unsupportedDialectOrDatabase=Unsupported dialect ''{0}'' encountered. Please ensure JDBC connection parameters are correct, and refer to the documentation to ensure that the connecting database is compatible with the Limitless Connection Plugin.

LimitlessRouterMonitor.exceptionDuringMonitoringStop=Stopping monitoring after unhandled exception was thrown in Limitless Router Monitoring thread for node {0}.
LimitlessRouterMonitor.interruptedExceptionDuringMonitoring=Limitless Router Monitoring thread for node {0} was interrupted.
LimitlessRouterMonitor.invalidQuery=Limitless Connection Plugin has encountered an error obtaining Limitless Router endpoints. Please ensure that you are connecting to an Aurora Limitless Database Shard Group Endpoint URL.
LimitlessRouterMonitor.invalidRouterLoad=Invalid load metric value of ''{1}''from the transaction router query pg_catalog.aurora_limitless_router_endpoints() for transaction router ''{0}''. The load metric value must be a decimal value between 0 and 1. Host weight be assigned a default weight of 1.
LimitlessRouterMonitor.getNetworkTimeoutError=An error occurred while getting the connection network timeout: {0}
LimitlessRouterMonitor.openingConnection=Opening Limitless Router Monitor connection to ''{0}''.
LimitlessRouterMonitor.openedConnection=Opened Limitless Router Monitor connection: {0}.
LimitlessRouterMonitor.running=Limitless Router Monitor thread running on node {0}.

LimitlessRouterServiceImpl.connectWithHost=Connecting to host {0}.
LimitlessRouterServiceImpl.errorStartingMonitor=An error occurred while starting Limitless Router Monitor: {0}
LimitlessRouterServiceImpl.failedToConnectToHost=Failed to connect to host {0}.
LimitlessRouterServiceImpl.fetchedEmptyRouterList=Empty router list was fetched.
LimitlessRouterServiceImpl.getLimitlessRoutersException=Exception encountered getting Limitless Routers. {0}
LimitlessRouterServiceImpl.incorrectConfiguration=Limitless Connection Plugin is unable to run. Please ensure the connection settings are correct.
LimitlessRouterServiceImpl.interruptedSynchronousGetRouter=Limitless Router Service thread was interrupted while waiting to fetch Limitless Transaction Routers.
LimitlessRouterServiceImpl.limitlessRouterCacheEmpty=Limitless Router cache is empty. This normal during application start up when the cache is not yet populated.
LimitlessRouterServiceImpl.maxRetriesExceeded=Max number of connection retries has been exceeded. Unable to connect to any transaction router.
LimitlessRouterServiceImpl.noRoutersAvailable=Unable to connect to any transaction router.
LimitlessRouterServiceImpl.noRoutersAvailableForRetry=No transaction routers available for connection retry. Retrying with original connection.
LimitlessRouterServiceImpl.unableToConnectNoRoutersAvailable=Unable to connect to original host {0}. All transaction routers are unavailable. Please verify connection credentials and network connectivity.
LimitlessRouterServiceImpl.selectedHost=Host {0} has been selected.
LimitlessRouterServiceImpl.selectedHostForRetry=Host {0} has been selected for connection retry.
LimitlessRouterServiceImpl.synchronouslyGetLimitlessRouters=Fetching Limitless Routers synchronously.
LimitlessRouterServiceImpl.usingProvidedConnectUrl=Connecting using provided connection URL.

LogQueryConnectionPlugin.executingQuery=[{0}] Executing query: {1}

HostMonitorConnectionContext.exceptionAbortingConnection=Exception during aborting connection: {0}
HostMonitorConnectionContext.hostDead=Host {0} is *dead*.
HostMonitorConnectionContext.hostNotResponding=Host {0} is not *responding* {1}.
HostMonitorConnectionContext.hostAlive=Host {0} is *alive*.

HostMonitorThreadContainer.emptyNodeKeys=Provided node keys are empty.

HostMonitorImpl.contextNullWarning=Parameter 'context' should not be null.
HostMonitorImpl.interruptedExceptionDuringMonitoring=Monitoring thread for node {0} was interrupted.
HostMonitorImpl.exceptionDuringMonitoringContinue=Continuing monitoring after unhandled exception was thrown in monitoring thread for node {0}.
HostMonitorImpl.exceptionDuringMonitoringStop=Stopping monitoring after unhandled exception was thrown in monitoring thread for node {0}.
HostMonitorImpl.monitorIsStopped=Monitoring was already stopped for node {0}.
HostMonitorImpl.startMonitoringThreadNewContext=Start monitoring thread for checking new contexts for {0}.
HostMonitorImpl.stopMonitoringThreadNewContext=Stop monitoring thread for checking new contexts for {0}.
HostMonitorImpl.startMonitoringThread=Start monitoring thread for {0}.
HostMonitorImpl.stopMonitoringThread=Stop monitoring thread for {0}.

HostMonitorServiceImpl.emptyAliasSet=Empty alias set passed for ''{0}''. Set should not be empty.

HostResponseTimeServiceImpl.errorStartingMonitor=An error occurred while starting a response time monitor for ''{0}'': {1}

MonitoringGlobalAuroraHostListProvider.globalHostPatternsRequired=Parameter 'globalClusterInstanceHostPatterns' is required for Aurora Global Database.

MonitorServiceImpl.checkingMonitors=Checking monitors for errors...
MonitorServiceImpl.monitorClassMismatch=The monitor stored at ''{0}'' did not have the expected type. The expected type was ''{1}'', but the monitor ''{2}'' had a type of ''{3}''.
MonitorServiceImpl.monitorStuck=Monitor ''{0}'' has not been updated within the inactive timeout of {1} milliseconds. The monitor will be stopped.
MonitorServiceImpl.monitorTypeNotRegistered=The given monitor class ''{0}'' is not registered. Please register the monitor class before running monitors of that class with the monitor service.
MonitorServiceImpl.removedExpiredMonitor=Removed expired monitor: ''{0}''.
MonitorServiceImpl.removedErrorMonitor=Removed monitor in error state: ''{0}''.
MonitorServiceImpl.recreatingMonitor=Recreating monitor: ''{0}''.
MonitorServiceImpl.stopAndRemoveMissingMonitorType=The monitor service received a request to stop a monitor with type ''{0}'' and key ''{1}'', but the monitor service does not have any monitors registered under the given type. Please ensure monitors are registered under the correct type.
MonitorServiceImpl.stopAndRemoveMonitorsMissingType=The monitor service received a request to stop all monitors with type ''{0}'', but the monitor service does not have any monitors registered under the given type. Please ensure monitors are registered under the correct type.
MonitorServiceImpl.unexpectedMonitorClass=Monitor type mismatch - the monitor ''{0}'' was unexpectedly found under the ''{1}'' monitor class category. Please verify that monitors are submitted under their concrete class.

NodeMonitoringThread.detectedWriter=Writer detected by node monitoring thread: ''{0}''.
NodeMonitoringThread.invalidWriterQuery=The writer topology query is invalid: {0}
NodeMonitoringThread.threadCompleted=Node monitoring thread completed in {0} ms.
NodeMonitoringThread.writerNodeChanged=Writer node changed from ''{0}'' to node ''{1}''.

OktaAuthPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.
OktaAuthPlugin.requiredDependenciesMissing=OktaAuthPlugin requires the 'AWS Java SDK for AWS Secret Token Service' and 'JSoup' dependencies. Both of these dependencies must be registered on the classpath.
OktaCredentialsProviderFactory.sessionTokenRequestFailed=Failed to retrieve session token from Okta, please ensure the provided Okta username, password and endpoint are correct.
OktaCredentialsProviderFactory.invalidSessionToken=Invalid response from session token request to Okta.
OktaCredentialsProviderFactory.unableToOpenHttpClient=Unable to open an HTTP client to sent requests.
OktaCredentialsProviderFactory.invalidSamlResponse=The SAML Assertion request did not return a valid response containing a SAMLResponse.
OktaCredentialsProviderFactory.samlRequestFailed=Okta SAML Assertion request failed with HTTP status ''{0}'', reason phrase ''{1}'', and response ''{2}''

PluginServiceImpl.currentHostNotAllowed=The current host is not in the list of allowed hosts. Current host: ''{0}''. Allowed hosts: {1}
PluginServiceImpl.hostListEmpty=Current host list is empty.
PluginServiceImpl.releaseResources=Releasing resources.
PluginServiceImpl.forceRefreshTimeout=A timeout exception occurred after waiting {0}ms for refreshed topology.
PluginServiceImpl.failedToRetrieveHostPort=Could not retrieve Host:Port for connection.
PluginServiceImpl.nonEmptyAliases=fillAliases called when HostSpec already contains the following aliases: ''{0}''.

PropertyUtils.setMethodDoesNotExistOnTarget=Set method for property ''{0}'' does not exist on target ''{1}''.
PropertyUtils.failedToSetProperty=Failed to set property ''{0}'' on target ''{1}''.
PropertyUtils.failedToSetPropertyWithReason=Failed to set property ''{0}'' on target ''{1}''. {2}

ReadWriteSplittingPlugin.setReadOnlyOnClosedConnection=setReadOnly cannot be called on a closed connection.
ReadWriteSplittingPlugin.errorSwitchingToCachedReader=An error occurred while trying to switch to a cached reader connection: ''{0}''. The driver will attempt to establish a new reader connection.
ReadWriteSplittingPlugin.errorSwitchingToCachedReaderWithCause=An error occurred while trying to switch to a cached reader connection: ''{0}''. Error message: ''{1}''. The driver will attempt to establish a new reader connection.
ReadWriteSplittingPlugin.errorSwitchingToReader=An error occurred while trying to switch to a reader connection. {0}
ReadWriteSplittingPlugin.errorSwitchingToWriter=An error occurred while trying to switch to a writer connection.
ReadWriteSplittingPlugin.closingInternalConnections=Closing all internal connections except for the current one.
ReadWriteSplittingPlugin.setReaderConnection=Reader connection set to ''{0}''
ReadWriteSplittingPlugin.setWriterConnection=Writer connection set to ''{0}''
ReadWriteSplittingPlugin.setReadOnlyFalseInTransaction=setReadOnly(false) was called on a read-only connection inside a transaction. Please complete the transaction before calling setReadOnly(false).
ReadWriteSplittingPlugin.fallbackToWriter=Failed to switch to a reader. {0}. The current writer will be used as a fallback: ''{1}''
ReadWriteSplittingPlugin.switchedFromWriterToReader=Switched from a writer to a reader host. New reader host: ''{0}''
ReadWriteSplittingPlugin.switchedFromReaderToWriter=Switched from a reader to a writer host. New writer host: ''{0}''
ReadWriteSplittingPlugin.settingCurrentConnection=Setting the current connection to ''{0}''
ReadWriteSplittingPlugin.noWriterFound=No writer was found in the current host list. This may occur if the writer is not in the list of allowed hosts.
ReadWriteSplittingPlugin.noReadersFound=A reader instance was requested via setReadOnly, but there are no readers in the host list. The current writer will be used as a fallback: ''{0}''
ReadWriteSplittingPlugin.emptyHostList=Host list is empty.
ReadWriteSplittingPlugin.exceptionWhileExecutingCommand=Detected an exception while executing a command: ''{0}''
ReadWriteSplittingPlugin.failoverExceptionWhileExecutingCommand=Detected a failover exception while executing a command: ''{0}''
ReadWriteSplittingPlugin.executingAgainstOldConnection=Executing method against old connection: ''{0}''
ReadWriteSplittingPlugin.noReadersAvailable=The plugin was unable to establish a reader connection to any reader instance.
ReadWriteSplittingPlugin.successfullyConnectedToReader=Successfully connected to reader host: ''{0}''
ReadWriteSplittingPlugin.failedToConnectToReader=Failed to connect to reader host: ''{0}''
ReadWriteSplittingPlugin.unsupportedHostSpecSelectorStrategy=Unsupported host selection strategy ''{0}'' specified in plugin configuration parameter ''readerHostSelectorStrategy''. Please visit the Read/Write Splitting Plugin documentation for all supported strategies.
ReadWriteSplittingPlugin.errorVerifyingInitialHostSpecRole=An error occurred while obtaining the connected host's role. This could occur if the connection is broken or if you are not connected to an Aurora database.
ReadWriteSplittingPlugin.previousReaderNotAllowed=The previous reader connection cannot be used because it is no longer in the list of allowed hosts. Previous reader: {0}. Allowed hosts: {1}
ReadWriteSplittingPlugin.fallbackToCurrentConnection=Failed to switch to reader host. The current connection will be used as a fallback: ''{0}''. Error:  {1}

SimpleReadWriteSplittingPlugin.verificationFailed=The plugin was unable to establish a {0} connection within {1} ms.
SimpleReadWriteSplittingPlugin.failedToConnectToWriter=A writer connection was requested via setReadOnly, but the plugin was unable to establish a writer connection with the writer endpoint ''{0}''.
SimpleReadWriteSplittingPlugin.missingRequiredConfigParameter=Configuration parameter ''{0}'' is required.

SAMLCredentialsProviderFactory.getSamlAssertionFailed=Failed to get SAML Assertion due to exception: ''{0}''
SamlAuthPlugin.javaStsSdkNotInClasspath=Required dependency 'AWS Java SDK for AWS Secret Token Service' is not on the classpath.
SamlAuthPlugin.unhandledException=Unhandled exception: ''{0}''

ServicesContainerPluginFactory.servicesContainerRequired=The {0} requires a FullServicesContainer. Please use getInstance(FullServicesContainer, Properties) instead.

StorageServiceImpl.unexpectedValueMismatch=Attempted to store value ''{0}'' under item class ''{1}'' but there was an unexpected mismatch between the passed in value type and the expected value type. The cache for item class ''{1}'' is ''{2}''.
StorageServiceImpl.itemClassNotRegistered=The given item class ''{0}'' is not registered. Please register the item class before storing items of that class.
StorageServiceImpl.itemClassMismatch=The item stored at ''{0}'' did not have the expected type. The expected type was ''{1}'', but the stored item ''{2}'' had a type of ''{3}''. Returning null.
StorageServiceImpl.removeExpiredItems=Removing expired items from the storage service...

WeightedRandomHostSelector.hostWeightPairsPropertyRequired=A host was requested from the WeightedRandomHostSelector but the required ''weightedRandomHostWeightPairs'' property was not provided.

WrapperUtils.noWrapperClassExists=No wrapper class exists for ''{0}''.
WrapperUtils.failedToInitializeClass=Can''t initialize class ''{0}''.

AuroraStaleDnsHelper.clusterEndpointDns=Cluster endpoint resolves to {0}.
AuroraStaleDnsHelper.currentWriterNotAllowed=The current writer is not in the list of allowed hosts. Current host: ''{0}''. Allowed hosts: {1}
AuroraStaleDnsHelper.writerHostSpec=Writer host: {0}
AuroraStaleDnsHelper.writerInetAddress=Writer host address: {0}
AuroraStaleDnsHelper.staleDnsDetected=Stale DNS data detected. Opening a connection to ''{0}''.
AuroraStaleDnsHelper.reset=Reset stored writer host.

OpenedConnectionTracker.invalidatingConnections=Invalidating opened connections to host: ''{0}''

Utils.topology={0} \n{1}

DialectManager.unknownDialectCode=Unknown dialect code: ''{0}''.
DialectManager.unknownDialect=Database dialect can''t be identified. Use configuration parameter ''wrapperDialect'' to configure it.

TargetDriverDialectManager.unknownDialectCode=Unknown target driver dialect code: ''{0}''.
TargetDriverDialectManager.unknownProtocol=Can not find a driver to register for protocol ''{0}''.
TargetDriverDialectManager.customDialectNotSupported=Provided custom target driver dialect will be ignored.
TargetDriverDialectManager.useDialect=Target driver dialect set to: ''{0}'', {1}.
TargetDriverDialectManager.unexpectedClass=Unexpected DataSource class. Expected class(es): {0}, actual class: {1}.
TargetDriverDialect.unsupported=This target driver dialect does not support this operation.
MysqlConnectorJDriverHelper.canNotRegister=Can''t register driver  com.mysql.cj.jdbc.Driver.

TopologyUtils.errorGettingHostRole=An error occurred while obtaining the connected host's role. This could occur if the connection is broken or if you are not connected to an Aurora database.
TopologyUtils.errorGettingNetworkTimeout=An error occurred while getting the connection network timeout: {0}
TopologyUtils.errorProcessingQueryResults=An error occurred while processing the results from the topology query: {0}
TopologyUtils.invalidQuery=An error occurred while attempting to obtain the topology because the topology query was invalid. Please ensure you are connecting to an Aurora or RDS cluster.
TopologyUtils.unexpectedTopologyQueryColumnCount=The topology query returned a result with 0 columns. This may occur if the topology query is executed when the server is failing over.

MariadbDriverHelper.canNotRegister=Can''t register driver  org.mariadb.jdbc.Driver.

AuroraInitialConnectionStrategyPlugin.incorrectRole=The Aurora Initial Connection Strategy Plugin connected to ''{0}'', but the connected instance did not have the requested ''{1}'' role. Retrying connection attempt...
AuroraInitialConnectionStrategyPlugin.invalidSettingForEndpoint=Parameter ''{0}'' cannot be set to ''{1}'' when using a {2} endpoint. Please see the Aurora Initial Connection Strategy Plugin documentation for valid setting/endpoint combinations.
AuroraInitialConnectionStrategyPlugin.invalidSettingForInstanceEndpoint=Parameter ''{0}'' cannot be set when using an instance endpoint. Please see the Aurora Initial Connection Strategy Plugin documentation for valid setting/endpoint combinations.
AuroraInitialConnectionStrategyPlugin.invalidPropertyValue=Received an invalid value for parameter ''{0}''. Received ''{1}'', valid values are {2}.
AuroraInitialConnectionStrategyPlugin.timeout=The Aurora Initial Connection Strategy Plugin attempted to connect but timed out after {0}ms. Please ensure that your URL is correct, there are no network issues, and you are connecting to the correct role if ''{1}'' was set.
AuroraInitialConnectionStrategyPlugin.unsupportedStrategy=Unsupported host selection strategy ''{0}''.
AuroraInitialConnectionStrategyPlugin.verifyReaderConfiguredButNoReadersExist=Parameter ''{0}'' was set to ''reader'' but no readers were detected in the topology. The writer will be used as a fallback.

NodeResponseTimeMonitor.responseTime=Response time for ''{0}'': {1} ms
NodeResponseTimeMonitor.interruptedExceptionDuringMonitoring=Response time thread for node {0} was interrupted.
NodeResponseTimeMonitor.exceptionDuringMonitoringStop=Stopping thread after unhandled exception was thrown in Response time thread for node {0}.
NodeResponseTimeMonitor.openingConnection=Opening a Response time connection to ''{0}''.
NodeResponseTimeMonitor.openedConnection=Opened Response time connection: {0}.

ClusterTopologyMonitorImpl.startMonitoringThread=[clusterId: ''{0}''] Start cluster topology monitoring thread for ''{1}''.
ClusterTopologyMonitorImpl.stopMonitoringThread=Stop cluster topology monitoring thread for ''{0}''.
ClusterTopologyMonitorImpl.exceptionDuringMonitoringStop=Stopping cluster topology monitoring after unhandled exception was thrown in monitoring thread for node ''{0}''.
ClusterTopologyMonitorImpl.topologyNotUpdated=Topology has not been updated after {0} ms.
ClusterTopologyMonitorImpl.openedMonitoringConnection=Opened monitoring connection to node ''{0}''.
ClusterTopologyMonitorImpl.ignoringTopologyRequest=A topology refresh was requested, but the topology was already updated recently. Returning cached hosts:
ClusterTopologyMonitorImpl.timeoutSetToZero=A topology refresh was requested, but the given timeout for the request was 0ms. Returning cached hosts:
ClusterTopologyMonitorImpl.interrupted=The thread was interrupted while waiting for updated topology.
ClusterTopologyMonitorImpl.startingNodeMonitoringThreads=Starting node monitoring threads.
ClusterTopologyMonitorImpl.writerPickedUpFromNodeMonitors=The writer host detected by the node monitors was picked up by the topology monitor: ''{0}''.
ClusterTopologyMonitorImpl.writerMonitoringConnection=The monitoring connection is connected to a writer: ''{0}''.
ClusterTopologyMonitorImpl.errorFetchingTopology=An error occurred while querying for topology: {0}
ClusterTopologyMonitorImpl.reset=Reset: clusterId={0}, host={1}
ClusterTopologyMonitorImpl.resetEventReceived=MonitorResetEvent received.

# Blue/Green Deployment

bgd.forceRefreshTimeout=Timed out while waiting for forceRefresh to return new topology info.
bgd.inProgressConnectionClosed=Connection has been closed since Blue/Green switchover is in progress.
bgd.inProgressHoldConnect=Blue/Green Deployment switchover is in progress. The  ''connect'' call will be delayed until switchover is completed.
bgd.inProgressTryConnectLater=Blue/Green Deployment switchover is still in progress after {0} ms. Try to connect again later.
bgd.switchoverCompleteContinueWithConnect=Blue/Green Deployment switchover is completed. Continue with connect call. The call was held for {0} ms.
bgd.inProgressSuspendMethod=Blue/Green Deployment switchover is in progress. Suspend ''{0}'' call until switchover is completed.
bgd.stillInProgressTryMethodLater=Blue/Green Deployment switchover is still in progress after {0} ms. Try ''{1}'' again later.
bgd.switchoverCompletedContinueWithMethod=Blue/Green Deployment switchover is completed. Continue with ''{0}'' call. The call was held for {1} ms.
bgd.inProgressCantConnect=Blue/Green Deployment switchover is in progress. New connection can''t be opened.
bgd.requireIamHost=Connecting with IP address when IAM authentication is enabled requires an ''iamHost'' parameter.
bgd.inProgressCantOpenConnection=Blue/Green Deployment switchover is in progress. Can''t establish connection to ''{0}''.
bgd.unknownRole=Unknown blue/green role ''{0}''.
bgd.unknownVersion=Unknown blue/green version ''{0}''.
bgd.unknownStatus=Unknown blue/green status ''{0}''.
bgd.statusChanged=[{0}] Status changed to: {1}
bgd.interrupted=[{0}] Interrupted.
bgd.monitoringUnhandledException=[{0}] Unhandled exception while monitoring blue/green status.
bgd.threadCompleted=[{0}] Blue/green status monitoring thread is completed.
bgd.statusNotAvailable=[{0}] (status not available) currentPhase: {1}
bgd.usesVersion=[{0}] Blue/Green deployment uses version ''{1}'' which the driver does not support. Version ''{2}'' will be used instead.
bgd.noEntriesInStatusTable=[{0}] No entries in status table.
bgd.exception=[{0}] currentPhase: {1}, exception while querying for blue/green status.
bgd.unhandledSqlException=[{0}] Unhandled SQLException.
bgd.unhandledException=[{0}] Unhandled exception.
bgd.openingConnectionWithIp=[{0}] Opening monitoring connection (IP) to {1}.
bgd.openedConnectionWithIp=[{0}] Opened monitoring connection (IP) to {1}.
bgd.openingConnection=[{0}] Opening monitoring connection to {1}.
bgd.openedConnection=[{0}] Opened monitoring connection to {1}.
bgd.createHostListProvider=[{0}] Creating a new HostListProvider, clusterId: {1}.
bgd.unsupportedDialect=[bgdId: ''{0}''] Blue/Green Deployments isn''t supported by database dialect {1}.
bgd.interimStatus=[bgdId: ''{0}'', role: {1}] {2}
bgd.rollback=[bgdId: ''{0}''] Blue/Green deployment is in rollback mode.
bgd.unknownPhase=[bgdId: ''{0}''] Unknown BG phase ''{1}''.
bgd.blueDnsCompleted=[bgdId: ''{0}''] Blue DNS update completed.
bgd.greenDnsRemoved=[bgdId: ''{0}''] Green DNS removed.
bgd.greenTopologyChanged=[bgdId: ''{0}''] Green topology changed.
bgd.switchoverTimeout=Blue/Green switchover has timed out.
bgd.greenNodeChangedName=Green node ''{0}'' has changed its name to ''{1}''.
bgd.resetContext=Resetting context.
bgd.hostSpecNull=Unable to initialize HostListProvider since connection host information is null.
bgd.waitConnectUntilCorrespondingNodeFound=Blue/Green Deployment switchover is in progress and a corresponding node for ''{0}'' is not found. The ''connect'' call will be delayed.
bgd.correspondingNodeNotFoundTryConnectLater=Blue/Green Deployment switchover is still in progress and a corresponding node for ''{0}'' is not found after {1} ms. Try to connect again later.
bgd.correspondingNodeFoundContinueWithConnect=A corresponding node for ''{0}'' is found. Continue with connect call. The call was held for {1} ms.
bgd.completedContinueWithConnect=Blue/Green Deployment status is completed. Continue with ''connect'' call. The call was held for {0} ms.

AtomicConnection.finalizingUnclosedConnection=Finalizing a connection that was never closed. Connection is opened from thread ''{0}''.
AtomicConnection.alreadyClean=The instance is already cleaned and can''t be used any more.

LazyCleanerImpl.interruptEmptyQueue=Got interrupt and the cleanup queue is empty, will terminate the cleanup thread.
LazyCleanerImpl.interruptNotEmptyQueue=Got interrupt and the cleanup queue is NOT empty. Will ignore the interrupt.
LazyCleanerImpl.unexpectedError=Unexpected exception while executing onClean.

GlobalDbFailoverConnectionPlugin.missingHomeRegion=Failover home region should be provided.
GlobalDbFailoverConnectionPlugin.startFailover=Starting failover procedure.
GlobalDbFailoverConnectionPlugin.failoverElapsed=Writer failover elapsed in {0} ms.
GlobalDbFailoverConnectionPlugin.isHomeRegion=GDB primary region is home region: {0}.
GlobalDbFailoverConnectionPlugin.candidateNull=Unable to find {0} in updated host list:
GlobalDbFailoverConnectionPlugin.currentFailoverMode=Failover mode in effect: {0}.

GdbReadWriteSplittingPlugin.missingHomeRegion=Unable to parse home region from endpoint ''{0}''. Please ensure you have set the ''gdbRwHomeRegion'' connection parameter.
GdbReadWriteSplittingPlugin.cantConnectWriterOutOfHomeRegion=Writer connection to ''{0}'' is not allowed since it is out of home region ''{1}''.
GdbReadWriteSplittingPlugin.noAvailableReadersInHomeRegion=No available reader nodes in home region ''{0}''.
GdbReadWriteSplittingPlugin.parameterValue={0}={1}

