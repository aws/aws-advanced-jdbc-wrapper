#
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# ADFS Credentials Provider Getter
AdfsCredentialsProviderFactory.failedLogin=Failed login. Could not obtain SAML Assertion from ADFS SignOn Page POST response: \n''{0}''
AdfsCredentialsProviderFactory.invalidHttpsUrl=Invalid HTTPS URL: ''{0}''
AdfsCredentialsProviderFactory.signOnPagePostActionUrl=ADFS SignOn Action URL: ''{0}''
AdfsCredentialsProviderFactory.signOnPagePostActionRequestFailed=ADFS SignOn Page POST action failed with HTTP status ''{0}'', reason phrase ''{1}'', and response ''{2}''
AdfsCredentialsProviderFactory.signOnPageRequestFailed=ADFS SignOn Page Request Failed with HTTP status ''{0}'', reason phrase ''{1}'', and response ''{2}''
AdfsCredentialsProviderFactory.signOnPageUrl=ADFS SignOn URL: ''{0}''

# Aurora Host List Connection Plugin
AuroraHostListConnectionPlugin.providerAlreadySet=Another dynamic host list provider has already been set: {0}.

Authentication.unsupportedHostname=Unsupported AWS hostname {0}. Amazon domain name in format *.AWS-Region.rds.amazonaws.com or *.rds.AWS-Region.amazonaws.com.cn is expected.
AuthenticationToken.useCachedToken=Use cached authentication token = ''{0}''
AuthenticationToken.generatedNewToken=Generated new authentication token = ''{0}''
AuthenticationToken.javaSdkNotInClasspath=Required dependency 'AWS Java SDK RDS v2.x' is not on the classpath.

# Aurora Host List Provider
RdsHostListProvider.clusterInstanceHostPatternNotSupportedForRDSProxy=An RDS Proxy url can''t be used as the 'clusterInstanceHostPattern' configuration setting.
RdsHostListProvider.clusterInstanceHostPatternNotSupportedForRdsCustom=A custom RDS url can''t be used as the 'clusterInstanceHostPattern' configuration setting.
RdsHostListProvider.invalidPattern=Invalid value for the 'clusterInstanceHostPattern' configuration setting - the host pattern must contain a '?' character as a placeholder for the DB instance identifiers of the instances in the cluster.
RdsHostListProvider.invalidTopology=The topology query returned an invalid topology - no writer instance detected.
RdsHostListProvider.suggestedClusterId=ClusterId ''{0}'' is suggested for url ''{1}''.
RdsHostListProvider.parsedListEmpty=Can''t parse connection string: ''{0}''
RdsHostListProvider.invalidQuery=Error obtaining host list. Provided database might not be an Aurora Db cluster
RdsHostListProvider.errorGettingHostRole=An error occurred while obtaining the connected host's role. This could occur if the connection is broken or if you are not connected to an Aurora database.
RdsHostListProvider.errorIdentifyConnection=An error occurred while obtaining the connection's host ID.
RdsHostListProvider.errorGettingNetworkTimeout=An error occurred while getting the connection network timeout: {0}

# AWS SDK
AwsSdk.unsupportedRegion=Unsupported AWS region ''{0}''. For supported regions please read https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html

# AWS Secrets Manager Connection Plugin
AwsSecretsManagerConnectionPlugin.endpointOverrideMisconfigured=The provided endpoint is invalid and could not be used to create a URI: `{0}`.
AwsSecretsManagerConnectionPlugin.endpointOverrideInvalidConnection=A connection to the provided endpoint could not be established: `{0}`.
AwsSecretsManagerConnectionPlugin.javaSdkNotInClasspath=Required dependency 'AWS Java SDK for AWS Secrets Manager' is not on the classpath.
AwsSecretsManagerConnectionPlugin.jacksonDatabindNotInClasspath=Required dependency 'Jackson Databind' is not on the classpath.
AwsSecretsManagerConnectionPlugin.failedToFetchDbCredentials=Was not able to either fetch or read the database credentials from AWS Secrets Manager. Ensure the correct secretId and region properties have been provided.
AwsSecretsManagerConnectionPlugin.missingRequiredConfigParameter=Configuration parameter ''{0}'' is required.
AwsSecretsManagerConnectionPlugin.unhandledException=Unhandled exception: ''{0}''

# AWS Wrapper Data Source
AwsWrapperDataSource.missingJdbcProtocol=Missing JDBC protocol. Could not construct URL.
AwsWrapperDataSource.missingTarget=JDBC url or Server name is required.
AwsWrapperDataSource.configurationProfileNotFound=Configuration profile ''{0}'' not found.

# Cluster Aware Reader Failover Handler
ClusterAwareReaderFailoverHandler.interruptedThread=Thread was interrupted.
ClusterAwareReaderFailoverHandler.attemptingReaderConnection=Trying to connect to host: ''{0}'', with properties ''{1}''
ClusterAwareReaderFailoverHandler.readerRequired=Connected to host ''{0}'' but it has a host role of ''{1}'' and does not meet the strict-reader requirement. The connection will be closed.
ClusterAwareReaderFailoverHandler.errorGettingHostRole=An error occurred while trying to determine the role of the host candidate: {0}
ClusterAwareReaderFailoverHandler.successfulReaderConnection=Connected to host: ''{0}''
ClusterAwareReaderFailoverHandler.failedReaderConnection=Failed to connect to host: ''{0}''
ClusterAwareReaderFailoverHandler.invalidTopology=''{0}'' was called with an invalid (null or empty) topology.
ClusterAwareReaderFailoverHandler.timeout=Reader failover timed out after {0}ms.

# Cluster Aware Writer Failover Handler
ClusterAwareWriterFailoverHandler.interruptedThread=Thread was interrupted.
ClusterAwareWriterFailoverHandler.successfullyReconnectedToWriterInstance=Successfully re-connected to the current writer instance: ''{0}''
ClusterAwareWriterFailoverHandler.failedToConnectToWriterInstance=Failed to connect to the writer instance.
ClusterAwareWriterFailoverHandler.successfullyConnectedToNewWriterInstance=Successfully connected to the new writer instance: ''{0}''
ClusterAwareWriterFailoverHandler.successfulConnectionInvalidTopology={0} successfully established a connection but doesn't contain a valid topology.
ClusterAwareWriterFailoverHandler.taskAAttemptReconnectToWriterInstance=[TaskA] Attempting to re-connect to the current writer instance: ''{0}'', with properties ''{1}''
ClusterAwareWriterFailoverHandler.failoverCalledWithInvalidTopology=Failover was called with an invalid (null or empty) topology.
ClusterAwareWriterFailoverHandler.taskAFinished=[TaskA] Finished
ClusterAwareWriterFailoverHandler.taskBAttemptConnectionToNewWriterInstance=[TaskB] Attempting to connect to a new writer instance, with properties ''{0}''
ClusterAwareWriterFailoverHandler.taskBFinished=[TaskB] Finished
ClusterAwareWriterFailoverHandler.taskBConnectedToReader=[TaskB] Connected to reader: ''{0}''
ClusterAwareWriterFailoverHandler.taskBFailedToConnectToAnyReader=[TaskB] Failed to connect to any reader.
ClusterAwareWriterFailoverHandler.taskBTopologyObtained=[TaskB] Topology obtained: {0}
ClusterAwareWriterFailoverHandler.taskBAttemptConnectionToNewWriter=[TaskB] Trying to connect to a new writer: ''{0}''
ClusterAwareWriterFailoverHandler.taskBEncounteredException=[TaskB] encountered an exception: {0}
ClusterAwareWriterFailoverHandler.taskAEncounteredException=[TaskA] encountered an exception: {0}
ClusterAwareWriterFailoverHandler.standaloneNode=[TaskB] Host {0} is not yet connected to a cluster. The cluster is still being reconfigured.
ClusterAwareWriterFailoverHandler.alreadyWriter=Current reader connection is actually a new writer connection.

# Connection String Host List Provider
ConnectionStringHostListProvider.parsedListEmpty=Can''t parse connection string: ''{0}''.
ConnectionStringHostListProvider.unsupportedIdentifyConnection=ConnectionStringHostListProvider does not support identifyConnection.

# Connection Plugin Manager
ConnectionPluginManager.releaseResources=Releasing resources.
ConnectionPluginManager.unknownPluginCode=Unknown plugin code: ''{0}''.
ConnectionPluginManager.unableToLoadPlugin=Unable to load connection plugin factory: ''{0}''.
ConnectionPluginManager.invokedAgainstOldConnection=The internal connection has changed since ''{0}'' was created. This is likely due to failover or read-write splitting functionality. To ensure you are using the updated connection, please re-create Statement and ResultSet objects after failover and/or calling setReadOnly.

# Connection Provider
ConnectionProvider.noConnection=The target driver did not return a connection.
ConnectionProvider.unsupportedHostSpecSelectorStrategy=Unsupported host selection strategy ''{0}'' specified for this connection provider ''{1}''. Please visit the documentation for all supported strategies.

# Connection Url Builder
ConnectionUrlBuilder.missingJdbcProtocol=Missing JDBC protocol and/or host name. Could not construct URL.

# Connection Url Parser
ConnectionUrlParser.protocolNotFound=Url should contain a driver protocol. Protocol is not found in url: ''{0}''

# Connect Time Connection Plugin
ConnectTimeConnectionPlugin.connectTime=Connected in {0} nanos.

# Connection Wrapper
ConnectionWrapper.unclosedConnectionInstantiated=Unclosed connection was instantiated at this point:
ConnectionWrapper.connectionNotOpen=Initial connection isn't open.
ConnectionWrapper.finalizingUnclosedConnection=Finalizing a connection that was never closed.

# Console Consumer
ConsoleConsumer.unexpectedOutputType=Unexpected outputType: ''{0}''.

CredentialsProviderFactory.failedToInitializeHttpClient=Failed to initialize HttpClient.
CredentialsProviderFactory.unsupportedIdp=Unsupported Identity Provider ''{0}''. Please visit to the documentation for supported Identity Providers.

# Custom Endpoint Monitor Impl
CustomEndpointMonitorImpl.clearCache=Clearing info in the custom endpoint monitor info cache.
CustomEndpointMonitorImpl.detectedChangeInCustomEndpointInfo=Detected change in custom endpoint info for ''{0}'':\n{1}
CustomEndpointMonitorImpl.exception=Encountered an exception while monitoring custom endpoint ''{0}''.
CustomEndpointMonitorImpl.interrupted=Custom endpoint monitor for ''{0}'' was interrupted.
CustomEndpointMonitorImpl.interruptedWhileTerminating=Interrupted while awaiting termination of custom endpoint monitor for ''{0}''. The monitor will be forcefully shut down.
CustomEndpointMonitorImpl.monitorTerminationTimeout=Timed out after waiting {0} seconds for custom endpoint monitor for ''{1}'' to terminate gracefully. The monitor will be forcefully shut down.
CustomEndpointMonitorImpl.startingMonitor=Starting custom endpoint monitor for ''{0}''.
CustomEndpointMonitorImpl.stoppedMonitor=Stopped custom endpoint monitor for ''{0}''.
CustomEndpointMonitorImpl.stoppingMonitor=Stopping custom endpoint monitor for ''{0}''.
CustomEndpointMonitorImpl.unexpectedNumberOfEndpoints=Unexpected number of custom endpoints with endpoint identifier ''{0}'' in region ''{1}''. Expected 1, but found {2}. Endpoints:\n{3}.

# Custom Endpoint Plugin
CustomEndpointPlugin.timedOutWaitingForCustomEndpointInfo=The custom endpoint plugin timed out after {0}ms while waiting for custom endpoint info for host ''{1}''.
CustomEndpointPlugin.closeMonitors=Closing custom endpoint monitors. Active custom endpoint monitors will be stopped, closed, and removed from the monitors cache.
CustomEndpointPlugin.connectionRequestToCustomEndpoint=Detected a connection request to a custom endpoint URL: ''{0}''.
CustomEndpointPlugin.errorParsingEndpointIdentifier=Unable to parse custom endpoint identifier from URL: ''{0}''.
CustomEndpointPlugin.foundInfoInCache=Done waiting for custom endpoint info for ''{0}'':\n{1}
CustomEndpointPlugin.interruptedThread=The custom endpoint plugin was interrupted while waiting for custom endpoint info for host ''{0}''.
CustomEndpointPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.
CustomEndpointPlugin.waitingForCustomEndpointInfo=Custom endpoint info for ''{0}'' was not found. Waiting {1}ms for the endpoint monitor to fetch info...

# Custom Endpoint Plugin Factory
CustomEndpointPluginFactory.awsSdkNotInClasspath=Required dependency 'AWS Java SDK RDS v2.x' is not on the classpath.

# Data Cache Connection Plugin
DataCacheConnectionPlugin.queryResultsCached=[{0}] Query results will be cached: {1}

# Default Connection Plugin
DefaultConnectionPlugin.executingMethod=Executing method: ''{0}''
DefaultConnectionPlugin.noHostsAvailable=The default connection plugin received an empty host list from the plugin service.
DefaultConnectionPlugin.unknownRoleRequested=A HostSpec with a role of HostRole.UNKNOWN was requested via getHostSpecByStrategy. The requested role must be either HostRole.WRITER or HostRole.READER

# Driver
Driver.nullUrl=Url is null.
Driver.alreadyRegistered=Driver is already registered. It can only be registered once.
Driver.missingDriver=Can''t find the target driver for ''{0}''. Please ensure the target driver is in the classpath and is registered. Here is the list of registered drivers in the classpath: {1}
Driver.notRegistered=Driver is not registered (or it has not been registered using Driver.register() method).
Driver.urlParsingFailed=Url [{0}] parsing failed with error: [{1}]
Driver.configurationProfileNotFound=Configuration profile ''{0}'' not found.

# DataSource
DataSource.failedToSetProperty=Failed to set property ''{0}'' on target datasource ''{1}''.

# Execution Time Connection Plugin
ExecutionTimeConnectionPlugin.executionTime=Executed {0} in {1} nanos.

# Failover Connection Plugin
Failover.transactionResolutionUnknownError=Transaction resolution unknown. Please re-configure session state if required and try restarting the transaction.
Failover.connectionClosedExplicitly=Unable to failover, the connection has been explicitly closed.
Failover.connectionChangedError=The active SQL connection has changed due to a connection failure. Please re-configure session state if required.
Failover.exceptionConnectingToWriter=An exception occurred while trying to connect to the new writer ''{0}''.
Failover.failoverReaderTimeout=The reader failover process was not able to establish a connection before timing out.
Failover.failoverReaderUnableToRefreshHostList=The request to discover the new topology was unsuccessful.
Failover.noWriterHostAfterReconnecting=The writer failover process successfully reconnected, but no writer was found in the updated topology: {0}
Failover.nullReaderFailoverHandlerSupplier=The failover plugin was unable to create a reader failover handler because the supplier was unexpectedly null.
Failover.nullWriterFailoverHandlerSupplier=The failover plugin was unable to create a writer failover handler because the supplier was unexpectedly null.
Failover.parameterValue={0}={1}
Failover.unableToConnect=Unable to establish a SQL connection due to an unexpected error.
Failover.unableToConnectToWriter=Unable to establish SQL connection to the writer instance.
Failover.unableToConnectToReader=Unable to establish SQL connection to the reader instance.
Failover.unableToRefreshHostList=The request to discover the new topology timed out or was unsuccessful.
Failover.unexpectedReaderRole=The new writer was identified to be ''{0}'', but querying the instance for its role returned a role of {1}.
Failover.strictReaderUnknownHostRole=Unable to determine host role for ''{0}''. Since failover mode is set to STRICT_READER and the host may be a writer, it will not be selected for reader failover.
Failover.detectedException=Detected an exception while executing a command: {0}
Failover.failoverDisabled=Cluster-aware failover is disabled.
Failover.establishedConnection=Connected to: {0}
Failover.startWriterFailover=Starting writer failover procedure.
Failover.startReaderFailover=Starting reader failover procedure.
Failover.invalidNode=Node is no longer available in the topology: {0}
Failover.newWriterNotAllowed=The failover process identified the new writer but the host is not in the list of allowed hosts. New writer host: ''{0}''. Allowed hosts: {1}
Failover.noOperationsAfterConnectionClosed=No operations allowed after connection closed.
Failover.noWriterHost=Unable to find writer in updated host list.
Failover.readerCandidateNull=Unable to find reader in updated host list:
Failover.readerFailoverElapsed=Reader failover elapsed in {0} ms.
Failover.writerFailoverElapsed=Writer failover elapsed in {0} ms.
Failover.failedReaderConnection=[Reader Failover] Failed to connect to host: ''{0}''
Failover.errorSelectingReaderHost=An error occurred while attempting to select a reader host candidate: ''{0}''. Candidates:
Failover.skipFailoverOnInterruptedThread=Do not start failover since the current thread is interrupted.

# Federated Auth Plugin
FederatedAuthPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.

# HikariPooledConnectionProvider
HikariPooledConnectionProvider.errorConnectingWithDataSource=Unable to connect to ''{0}'' using the Hikari data source.
HikariPooledConnectionProvider.errorConnectingWithDataSourceWithCause=Unable to connect to ''{0}'' using the Hikari data source. Exception message: ''{1}''

# Host Availability Strategy
HostAvailabilityStrategy.invalidMaxRetries=Invalid value of {0} for configuration parameter `hostAvailabilityStrategyMaxRetries`. It must be an integer greater than 1.
HostAvailabilityStrategy.invalidInitialBackoffTime=Invalid value of {0}  for configuration parameter `hostAvailabilityStrategyInitialBackoffTime`. It must be an integer greater than 1.

# Host Monitoring Connection Plugin
HostMonitoringConnectionPlugin.activatedMonitoring=Executing method ''{0}'', monitoring is activated.
HostMonitoringConnectionPlugin.monitoringDeactivated=Monitoring deactivated for method ''{0}''.
HostMonitoringConnectionPlugin.unavailableNode=Node ''{0}'' is unavailable.
HostMonitoringConnectionPlugin.errorIdentifyingConnection=Error occurred while identifying connection: ''{0}''.
HostMonitoringConnectionPlugin.unableToIdentifyConnection=Unable to identify the given connection: ''{0}'', please ensure the correct host list provider is specified. The host list provider in use is: ''{1}''.

# HostSelector
HostSelector.noHostsMatchingRole=No hosts were found matching the requested ''{0}'' role.
HostSelector.roundRobinInvalidHostWeightPairs=The provided host weight pairs have not been configured correctly. Please ensure the provided host weight pairs is a comma separated list of pairs, each pair in the format of <host>:<weight>. Weight values must be an integer greater than or equal to the default weight value of 1.
HostSelector.roundRobinInvalidDefaultWeight=The provided default weight value is not valid. Weight values must be an integer greater than or equal to the default weight value of 1.

# IAM Auth Connection Plugin
IamAuthConnectionPlugin.unhandledException=Unhandled exception: ''{0}''
IamAuthConnectionPlugin.connectException=Error occurred while opening a connection: ''{0}''
IamAuthConnectionPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.

# Limitless Connection Plugin
LimitlessConnectionPlugin.failedToConnectToHost=Failed to connect to host {0}.
LimitlessConnectionPlugin.unsupportedDialectOrDatabase=Unsupported dialect ''{0}'' encountered. Please ensure JDBC connection parameters are correct, and refer to the documentation to ensure that the connecting database is compatible with the Limitless Connection Plugin.

# Limitless Query Helper
LimitlessQueryHelper.unsupportedDialectOrDatabase=Unsupported dialect ''{0}'' encountered. Please ensure JDBC connection parameters are correct, and refer to the documentation to ensure that the connecting database is compatible with the Limitless Connection Plugin.

# Limitless Router Monitor
LimitlessRouterMonitor.exceptionDuringMonitoringStop=Unhandled exception was thrown in Limitless Router Monitoring thread for node {0}.
LimitlessRouterMonitor.interruptedExceptionDuringMonitoring=Limitless Router Monitoring thread for node {0} was interrupted.
LimitlessRouterMonitor.invalidQuery=Limitless Connection Plugin has encountered an error obtaining Limitless Router endpoints. Please ensure that you are connecting to an Aurora Limitless Database Shard Group Endpoint URL.
LimitlessRouterMonitor.invalidRouterLoad=Invalid load metric value of ''{1}''from the transaction router query aurora_limitless_router_endpoints() for transaction router ''{0}''. The load metric value must be a decimal value between 0 and 1. Host weight be assigned a default weight of 1.
LimitlessRouterMonitor.getNetworkTimeoutError=An error occurred while getting the connection network timeout: {0}
LimitlessRouterMonitor.openingConnection=Opening Limitless Router Monitor connection to ''{0}''.
LimitlessRouterMonitor.openedConnection=Opened Limitless Router Monitor connection: {0}.
LimitlessRouterMonitor.running=Limitless Router Monitor thread running on node {0}.
LimitlessRouterMonitor.stopped=Limitless Router Monitor thread stopped on node {0].

# Limitless Router Service
LimitlessRouterServiceImpl.connectWithHost=Connecting to host {0}.
LimitlessRouterServiceImpl.errorStartingMonitor=An error occurred while starting Limitless Router Monitor. {0}
LimitlessRouterServiceImpl.failedToConnectToHost=Failed to connect to host {0}.
LimitlessRouterServiceImpl.fetchedEmptyRouterList=Empty router list was fetched.
LimitlessRouterServiceImpl.getLimitlessRoutersException=Exception encountered getting Limitless Routers. {0}
LimitlessRouterServiceImpl.incorrectConfiguration=Limitless Connection Plugin is unable to run. Please ensure the connection settings are correct.
LimitlessRouterServiceImpl.interruptedSynchronousGetRouter=Limitless Router Service thread was interrupted while waiting to fetch Limitless Transaction Routers.
LimitlessRouterServiceImpl.limitlessRouterCacheEmpty=Limitless Router cache is empty. This normal during application start up when the cache is not yet populated.
LimitlessRouterServiceImpl.maxRetriesExceeded=Max number of connection retries has been exceeded.
LimitlessRouterServiceImpl.noRoutersAvailable=No transaction routers available.
LimitlessRouterServiceImpl.noRoutersAvailableForRetry=No transaction routers available for connection retry. Retrying with original connection.
LimitlessRouterServiceImpl.selectedHost=Host {0} has been selected.
LimitlessRouterServiceImpl.selectedHostForRetry=Host {0} has been selected for connection retry.
LimitlessRouterServiceImpl.synchronouslyGetLimitlessRouters=Fetching Limitless Routers synchronously.
LimitlessRouterServiceImpl.usingProvidedConnectUrl=Connecting using provided connection URL.

# Log Query Connection Plugin
LogQueryConnectionPlugin.executingQuery=[{0}] Executing query: {1}

# Monitor Connection Context
MonitorConnectionContext.exceptionAbortingConnection=Exception during aborting connection: {0}
MonitorConnectionContext.hostDead=Host {0} is *dead*.
MonitorConnectionContext.hostNotResponding=Host {0} is not *responding* {1}.
MonitorConnectionContext.hostAlive=Host {0} is *alive*.

# Monitor Thread Container
MonitorThreadContainer.emptyNodeKeys=Provided node keys are empty.

# Monitor Impl
MonitorImpl.contextNullWarning=Parameter 'context' should not be null.
MonitorImpl.interruptedExceptionDuringMonitoring=Monitoring thread for node {0} was interrupted.
MonitorImpl.exceptionDuringMonitoringContinue=Continuing monitoring after unhandled exception was thrown in monitoring thread for node {0}.
MonitorImpl.exceptionDuringMonitoringStop=Stopping monitoring after unhandled exception was thrown in monitoring thread for node {0}.
MonitorImpl.monitorIsStopped=Monitoring was already stopped for node {0}.
MonitorImpl.stopped=Stopped monitoring thread for node ''{0}''.
MonitorImpl.startMonitoringThreadNewContext=Start monitoring thread for checking new contexts for {0}.
MonitorImpl.stopMonitoringThreadNewContext=Stop monitoring thread for checking new contexts for {0}.
MonitorImpl.startMonitoringThread=Start monitoring thread for {0}.
MonitorImpl.stopMonitoringThread=Stop monitoring thread for {0}.

# Monitor Service Impl
MonitorServiceImpl.emptyAliasSet=Empty alias set passed for ''{0}''. Set should not be empty.

NodeMonitoringThread.detectedWriter=Writer detected by node monitoring thread: ''{0}''.
NodeMonitoringThread.invalidWriterQuery=The writer topology query is invalid: {0}
NodeMonitoringThread.threadCompleted=Node monitoring thread completed in {0} ms.
NodeMonitoringThread.writerNodeChanged=Writer node changed from ''{0}'' to node ''{1}''.

OktaAuthPlugin.unableToDetermineRegion=Unable to determine connection region. If you are using a non-standard RDS URL, please set the ''{0}'' property.
OktaAuthPlugin.requiredDependenciesMissing=OktaAuthPlugin requires the 'AWS Java SDK for AWS Secret Token Service' and 'JSoup' dependencies. Both of these dependencies must be registered on the classpath.
OktaCredentialsProviderFactory.sessionTokenRequestFailed=Failed to retrieve session token from Okta, please ensure the provided Okta username, password and endpoint are correct.
OktaCredentialsProviderFactory.invalidSessionToken=Invalid response from session token request to Okta.
OktaCredentialsProviderFactory.unableToOpenHttpClient=Unable to open an HTTP client to sent requests.
OktaCredentialsProviderFactory.invalidSamlResponse=The SAML Assertion request did not return a valid response containing a SAMLResponse.
OktaCredentialsProviderFactory.samlRequestFailed=Okta SAML Assertion request failed with HTTP status ''{0}'', reason phrase ''{1}'', and response ''{2}''

# Plugin Service Impl
PluginServiceImpl.currentHostNotAllowed=The current host is not in the list of allowed hosts. Current host: ''{0}''. Allowed hosts: {1}
PluginServiceImpl.hostListEmpty=Current host list is empty.
PluginServiceImpl.releaseResources=Releasing resources.
PluginServiceImpl.forceRefreshTimeout=A timeout exception occurred after waiting {0}ms for refreshed topology.
PluginServiceImpl.hostsChangelistEmpty=There are no changes in the hosts' availability.
PluginServiceImpl.failedToRetrieveHostPort=Could not retrieve Host:Port for connection.
PluginServiceImpl.nonEmptyAliases=fillAliases called when HostSpec already contains the following aliases: ''{0}''.
PluginServiceImpl.requiredBlockingHostListProvider=The detected host list provider is not a BlockingHostListProvider. A BlockingHostListProvider is required to force refresh the host list. Detected host list provider: {0}

# Property Utils
PropertyUtils.setMethodDoesNotExistOnTarget=Set method for property ''{0}'' does not exist on target ''{1}''.
PropertyUtils.failedToSetProperty=Failed to set property ''{0}'' on target ''{1}''.
PropertyUtils.failedToSetPropertyWithReason=Failed to set property ''{0}'' on target ''{1}''. {2}

# Read Write Splitting Plugin
ReadWriteSplittingPlugin.setReadOnlyOnClosedConnection=setReadOnly cannot be called on a closed connection.
ReadWriteSplittingPlugin.errorSwitchingToCachedReader=An error occurred while trying to switch to a cached reader connection: ''{0}''. The driver will attempt to establish a new reader connection.
ReadWriteSplittingPlugin.errorSwitchingToCachedReaderWithCause=An error occurred while trying to switch to a cached reader connection: ''{0}''. Error message: ''{1}''. The driver will attempt to establish a new reader connection.
ReadWriteSplittingPlugin.errorSwitchingToReader=An error occurred while trying to switch to a reader connection. {0}
ReadWriteSplittingPlugin.errorSwitchingToWriter=An error occurred while trying to switch to a writer connection.
ReadWriteSplittingPlugin.closingInternalConnections=Closing all internal connections except for the current one.
ReadWriteSplittingPlugin.setReaderConnection=Reader connection set to ''{0}''
ReadWriteSplittingPlugin.setWriterConnection=Writer connection set to ''{0}''
ReadWriteSplittingPlugin.setReadOnlyFalseInTransaction=setReadOnly(false) was called on a read-only connection inside a transaction. Please complete the transaction before calling setReadOnly(false).
ReadWriteSplittingPlugin.fallbackToWriter=Failed to switch to a reader. {0}. The current writer will be used as a fallback: ''{1}''
ReadWriteSplittingPlugin.switchedFromWriterToReader=Switched from a writer to a reader host. New reader host: ''{0}''
ReadWriteSplittingPlugin.switchedFromReaderToWriter=Switched from a reader to a writer host. New writer host: ''{0}''
ReadWriteSplittingPlugin.settingCurrentConnection=Setting the current connection to ''{0}''
ReadWriteSplittingPlugin.noWriterFound=No writer was found in the current host list. This may occur if the writer is not in the list of allowed hosts.
ReadWriteSplittingPlugin.noReadersFound=A reader instance was requested via setReadOnly, but there are no readers in the host list. The current writer will be used as a fallback: ''{0}''
ReadWriteSplittingPlugin.emptyHostList=Host list is empty.
ReadWriteSplittingPlugin.exceptionWhileExecutingCommand=Detected an exception while executing a command: ''{0}''
ReadWriteSplittingPlugin.failoverExceptionWhileExecutingCommand=Detected a failover exception while executing a command: ''{0}''
ReadWriteSplittingPlugin.executingAgainstOldConnection=Executing method against old connection: ''{0}''
ReadWriteSplittingPlugin.noReadersAvailable=The plugin was unable to establish a reader connection to any reader instance.
ReadWriteSplittingPlugin.successfullyConnectedToReader=Successfully connected to a new reader host: ''{0}''
ReadWriteSplittingPlugin.failedToConnectToReader=Failed to connect to reader host: ''{0}''
ReadWriteSplittingPlugin.unsupportedHostSpecSelectorStrategy=Unsupported host selection strategy ''{0}'' specified in plugin configuration parameter ''readerHostSelectorStrategy''. Please visit the Read/Write Splitting Plugin documentation for all supported strategies.
ReadWriteSplittingPlugin.errorVerifyingInitialHostSpecRole=An error occurred while obtaining the connected host's role. This could occur if the connection is broken or if you are not connected to an Aurora database.

SAMLCredentialsProviderFactory.getSamlAssertionFailed=Failed to get SAML Assertion due to exception: ''{0}''
SamlAuthPlugin.javaStsSdkNotInClasspath=Required dependency 'AWS Java SDK for AWS Secret Token Service' is not on the classpath.
SamlAuthPlugin.unhandledException=Unhandled exception: ''{0}''

# Wrapper Utils
WrapperUtils.noWrapperClassExists=No wrapper class exists for ''{0}''.
WrapperUtils.failedToInitializeClass=Can''t initialize class ''{0}''.

# Aurora Stale DNS
AuroraStaleDnsPlugin.requireDynamicProvider=Dynamic host list provider is required.
AuroraStaleDnsHelper.clusterEndpointDns=Cluster endpoint resolves to {0}.
AuroraStaleDnsHelper.currentWriterNotAllowed=The current writer is not in the list of allowed hosts. Current host: ''{0}''. Allowed hosts: {1}
AuroraStaleDnsHelper.writerHostSpec=Writer host: {0}
AuroraStaleDnsHelper.writerInetAddress=Writer host address: {0}
AuroraStaleDnsHelper.staleDnsDetected=Stale DNS data detected. Opening a connection to ''{0}''.
AuroraStaleDnsHelper.reset=Reset stored writer host.

# Opened Connection Tracker
OpenedConnectionTracker.invalidatingConnections=Invalidating opened connections to host: ''{0}''

# Util
Utils.topology={0} \n{1}

# Dialect Manager
DialectManager.unknownDialectCode=Unknown dialect code: ''{0}''.
DialectManager.unknownDialect=Database dialect can''t be identified. Use configuration parameter ''wrapperDialect'' to configure it.

# Target Driver Dialect Manager
TargetDriverDialectManager.unknownDialectCode=Unknown target driver dialect code: ''{0}''.
TargetDriverDialectManager.unknownProtocol=Can not find a driver to register for protocol ''{0}''.
TargetDriverDialectManager.customDialectNotSupported=Provided custom target driver dialect will be ignored.
TargetDriverDialectManager.useDialect=Target driver dialect set to: ''{0}'', {1}.
TargetDriverDialectManager.unexpectedClass=Unexpected DataSource class. Expected class(es): {0}, actual class: {1}.
TargetDriverDialect.unsupported=This target driver dialect does not support this operation.
MysqlConnectorJDriverHelper.canNotRegister=Can''t register driver  com.mysql.cj.jdbc.Driver.
MariadbDriverHelper.canNotRegister=Can''t register driver  org.mariadb.jdbc.Driver.

# Aurora Initial Connection Strategy Plugin
AuroraInitialConnectionStrategyPlugin.unsupportedStrategy=Unsupported host selection strategy ''{0}''.
AuroraInitialConnectionStrategyPlugin.requireDynamicProvider=Dynamic host list provider is required.

# Fastest Response Time Strategy Plugin
NodeResponseTimeMonitor.stopped=Stopped Response time thread for node ''{0}''.
NodeResponseTimeMonitor.responseTime=Response time for ''{0}'': {1} ms
NodeResponseTimeMonitor.interruptedExceptionDuringMonitoring=Response time thread for node {0} was interrupted.
NodeResponseTimeMonitor.exceptionDuringMonitoringStop=Stopping thread after unhandled exception was thrown in Response time thread for node {0}.
NodeResponseTimeMonitor.openingConnection=Opening a Response time connection to ''{0}''.
NodeResponseTimeMonitor.openedConnection=Opened Response time connection: {0}.

# Monitoring RDS HostList Provider
ClusterTopologyMonitorImpl.startMonitoringThread=Start cluster topology monitoring thread for ''{0}''.
ClusterTopologyMonitorImpl.stopMonitoringThread=Stop cluster topology monitoring thread for ''{0}''.
ClusterTopologyMonitorImpl.exceptionDuringMonitoringStop=Stopping cluster topology monitoring after unhandled exception was thrown in monitoring thread for node ''{0}''.
ClusterTopologyMonitorImpl.invalidQuery=An error occurred while attempting to obtain the topology because the topology query was invalid. Please ensure you are connecting to an Aurora or RDS Db cluster.
ClusterTopologyMonitorImpl.errorGettingNetworkTimeout=An error occurred while getting the connection network timeout: {0}
ClusterTopologyMonitorImpl.invalidTopology=The topology query returned an invalid topology - no writer instance detected.
ClusterTopologyMonitorImpl.topologyNotUpdated=Topology hasn''t been updated after {0} ms.
ClusterTopologyMonitorImpl.openedMonitoringConnection=Opened monitoring connection to node ''{0}''.
ClusterTopologyMonitorImpl.ignoringTopologyRequest=A topology refresh was requested, but the topology was already updated recently. Returning cached hosts:
ClusterTopologyMonitorImpl.timeoutSetToZero=A topology refresh was requested, but the given timeout for the request was 0ms. Returning cached hosts:
ClusterTopologyMonitorImpl.interrupted=The thread was interrupted while waiting for updated topology.
ClusterTopologyMonitorImpl.startingNodeMonitoringThreads=Starting node monitoring threads.
ClusterTopologyMonitorImpl.writerPickedUpFromNodeMonitors=The writer host detected by the node monitors was picked up by the topology monitor: ''{0}''.
ClusterTopologyMonitorImpl.writerMonitoringConnection=The monitoring connection is connected to a writer: ''{0}''.
ClusterTopologyMonitorImpl.errorFetchingTopology=An error occurred while querying for topology: {0}
ClusterTopologyMonitorImpl.errorProcessingQueryResults=An error occurred while processing the results from the topology query: {0}
ClusterTopologyMonitorImpl.unexpectedTopologyQueryColumnCount=The topology query returned a result with 0 columns. This may occur if the topology query is executed when the server is failing over.
