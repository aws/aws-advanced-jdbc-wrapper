/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package integration.container.tests.hibernate;

import static org.hibernate.annotations.QueryHints.COMMENT;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import integration.*;
import integration.container.ConnectionStringHelper;
import integration.container.TestDriver;
import integration.container.TestDriverProvider;
import integration.container.TestEnvironment;
import integration.container.condition.*;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.logging.Logger;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.query.Query;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;

@TestMethodOrder(MethodOrderer.MethodName.class)
@EnableOnTestFeature(TestEnvironmentFeatures.VALKEY_CACHE)
@MakeSureFirstInstanceWriter
@Order(21)
public class HibernateCachingTests {
  private static final Logger LOGGER = Logger.getLogger(HibernateCachingTests.class.getName());

  private static boolean isInit = false;

  @BeforeEach
  public void beforeEach() throws SQLException {
    if (isInit) {
      return;
    }

    isInit = true;

    switch (TestEnvironment.getCurrent().getInfo().getRequest().getDatabaseEngine()) {
      case MYSQL:
      case MARIADB:
        try (Connection conn = DriverHelper.getDriverConnection(TestEnvironment.getCurrent().getInfo());
            Statement statement = conn.createStatement()) {
          statement.executeUpdate(
              "create table Skill (id integer not null auto_increment, name varchar(255), primary key (id))");
          statement.executeUpdate(
              "create table Tool (id integer not null auto_increment, name varchar(255), primary key (id))");
          statement.executeUpdate(
              "create table Users (id integer not null auto_increment, email varchar(255), name varchar(255), "
              + "phone varchar(255), primary key (id))");
          statement.executeUpdate(
              "create table Users_Skill (User_id integer not null, skills_id integer not null, "
              + "primary key (User_id, skills_id))");
          statement.executeUpdate(
              "create table Users_Tool (User_id integer not null, tools_id integer not null, "
              + "primary key (User_id, tools_id))");
          statement.executeUpdate(
              "alter table Users add constraint UK1 unique (email)");
          statement.executeUpdate(
              "alter table Users_Skill add constraint FK1 foreign key (skills_id) references Skill (id)");
          statement.executeUpdate(
              "alter table Users_Skill add constraint FK2 foreign key (User_id) references Users (id)");
          statement.executeUpdate(
              "alter table Users_Tool add constraint FK3 foreign key (tools_id) references Tool (id)");
          statement.executeUpdate(
              "alter table Users_Tool add constraint FK4 foreign key (User_id) references Users (id)");
          statement.executeUpdate(
              "create table Plane (id integer not null auto_increment, name varchar(255), primary key (id))");
        }
        break;
      case PG:
        try (Connection conn = DriverHelper.getDriverConnection(TestEnvironment.getCurrent().getInfo());
            Statement statement = conn.createStatement()) {
          statement.executeUpdate(
              "create table Skill (id integer not null generated by default as identity, "
              + "name varchar(255), primary key (id))");
          statement.executeUpdate(
              "create table Tool (id integer not null generated by default as identity, "
              + "name varchar(255), primary key (id))");
          statement.executeUpdate(
              "create table Users (id integer not null generated by default as identity, "
              + "email varchar(255), name varchar(255), "
              + "phone varchar(255), primary key (id))");
          statement.executeUpdate(
              "create table Users_Skill (User_id integer not null, skills_id integer not null)");
          statement.executeUpdate(
              "create table Users_Tool (User_id integer not null, tools_id integer not null)");
          statement.executeUpdate(
              "alter table Users add constraint UK1 unique (email)");
          statement.executeUpdate(
              "alter table Users_Skill add constraint FK1 foreign key (skills_id) references Skill (id)");
          statement.executeUpdate(
              "alter table Users_Skill add constraint FK2 foreign key (User_id) references Users (id)");
          statement.executeUpdate(
              "alter table Users_Tool add constraint FK3 foreign key (tools_id) references Tool (id)");
          statement.executeUpdate(
              "alter table Users_Tool add constraint FK4 foreign key (User_id) references Users (id)");
          statement.executeUpdate(
              "create table Plane (id integer not null generated by default as identity, "
                  + "name varchar(255), primary key (id))");
        }
        break;
      default:
        throw new UnsupportedOperationException(
            TestEnvironment.getCurrent().getInfo().getRequest().getDatabaseEngine().toString());
    }
  }

  @TestTemplate
  @ExtendWith(TestDriverProvider.class)
  public void testSimpleTest() {

    final Configuration configuration = this.getConfiguration();
    try (StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
        .applySettings(configuration.getProperties())
        .build()) {

      SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);

      try (Session session = sessionFactory.openSession()) {
        Tool tool = new Tool();
        tool.setName("Hammer");
        this.insertObject(session, tool);
        List<Tool> tools = new ArrayList<>();
        tools.add(tool);

        Skill skill = new Skill();
        skill.setName("Hammering Things");
        this.insertObject(session, skill);
        List<Skill> skills = new ArrayList<>();
        skills.add(skill);

        String email = String.format("foo_%d@foo.com", new Random().nextInt(1000000));

        User user = new User();
        user.setName("Brett Meyer");
        user.setEmail(email);
        user.setPhone("123-456-7890");
        user.setTools(tools);
        user.setSkills(skills);

        this.insertObject(session, user);

        User savedUser = queryUserNoCaching(session, user.getId());
        validateUserData(savedUser, "Brett Meyer", email, "123-456-7890");

        // Query the user from the DB and populate the cache with the user info
        User savedQueryUser = queryUserWithCaching(session, user.getId());
        validateUserData(savedQueryUser, "Brett Meyer", email, "123-456-7890");

        // Fetch the result again, this time it should come from the cache
        User savedQueryUser2 = queryUserWithCaching(session, user.getId());
        validateUserData(savedQueryUser2, "Brett Meyer", email, "123-456-7890");

        // Insert Plane data
        this.insertObject(session, new Plane("Boeing 787 Dreamliner"));
        this.insertObject(session, new Plane("Boeing 737 MAX"));
        this.insertObject(session, new Plane("Airbus 320"));

        // Named query using annotation-based hint
        List<Plane> planes = session.createNamedQuery("Plane.findAll", Plane.class).getResultList();
        assertEquals(3, planes.size());

        // Clear the tables
        session.getTransaction().begin();
        assertEquals(3, session.createQuery("delete from Plane").executeUpdate());
        assertEquals(1, session.createQuery("delete from User").executeUpdate());
        assertEquals(1, session.createQuery("delete from Skill").executeUpdate());
        assertEquals(1, session.createQuery("delete from Tool").executeUpdate());
        session.getTransaction().commit();

        // Fetch the planes data and user data from the cache.
        User savedQueryUser3 = queryUserWithCaching(session, user.getId());
        validateUserData(savedQueryUser3, "Brett Meyer", email, "123-456-7890");

        List<Plane> planes2 = session.createNamedQuery("Plane.findAll", Plane.class).getResultList();
        assertEquals(3, planes2.size());
      }
    }
  }

  private void validateUserData(User user, String name, String email, String phone) {
    assertNotNull(user);
    assertEquals(name, user.getName());
    assertEquals(email, user.getEmail());
    assertEquals(phone, user.getPhone());
    assertEquals(1, user.getSkills().size());
    assertEquals(1, user.getTools().size());
  }

  private Configuration getConfiguration() {
    String url = ConnectionStringHelper.getWrapperUrl();
    LOGGER.finest("Connecting to " + url);

    final Configuration configuration = new Configuration();
    configuration.addAnnotatedClass(User.class);
    configuration.addAnnotatedClass(Tool.class);
    configuration.addAnnotatedClass(Skill.class);
    configuration.addAnnotatedClass(Plane.class);

    DatabaseEngine databaseEngine = TestEnvironment.getCurrent().getInfo().getRequest().getDatabaseEngine();

    switch (databaseEngine) {
      case PG:
        configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");
        break;
      case MYSQL:
        configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect");
        break;
      case MARIADB:
        configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.MariaDBDialect");
        break;
      default:
        throw new UnsupportedOperationException(databaseEngine.toString());
    }

    configuration.setProperty("hibernate.connection.driver_class", "software.amazon.jdbc.Driver");

    configuration.setProperty("hibernate.show_sql", "true");
    configuration.setProperty("hibernate.format_sql", "true");
    configuration.setProperty("hibernate.hbm2ddl.auto", "none");
    configuration.setProperty("hibernate.connection.url", url);
    configuration.setProperty("hibernate.connection.username",
        TestEnvironment.getCurrent().getInfo().getProxyDatabaseInfo().getUsername());
    configuration.setProperty("hibernate.connection.password",
        TestEnvironment.getCurrent().getInfo().getProxyDatabaseInfo().getPassword());
    configuration.setProperty("hibernate.connection.pool_size", "1");

    // Additional Wrapper driver properties
    configuration.setProperty("hibernate.connection.connectTimeout", "10000");
    configuration.setProperty("hibernate.connection.socketTimeout", "10000");
    configuration.setProperty("hibernate.connection.enableTelemetry", "false");
    configuration.setProperty("hibernate.connection.tcpKeepAlive", "true");

    // Fetch the cache server information
    List<TestInstanceInfo> cacheInstances = TestEnvironment.getCurrent().getInfo().getDbCacheInfo().getInstances();
    final String cacheEndpoint = cacheInstances.get(0).getHost() + ":" + cacheInstances.get(0).getPort();

    // Caching enablement and configuration
    configuration.setProperty("hibernate.use_sql_comments", "true");
    configuration.setProperty("hibernate.connection.wrapperPlugins", "dataRemoteCache");
    configuration.setProperty("hibernate.connection.cacheEndpointAddrRw", cacheEndpoint);
    configuration.setProperty("hibernate.connection.cacheUseSSL", "false");

    if (TestEnvironment.getCurrent().getCurrentDriver() == TestDriver.MARIADB) {
      // This property is sometimes required when using the mariadb driver against multi-az mysql version 8.4, or you
      // will get the error "RSA public key is not available client side" when connecting. The mariadb driver may not
      // fully support mysql 8.4's SSL mechanisms, which is why this property is only required for newer mysql versions.
      configuration.setProperty("hibernate.connection.allowPublicKeyRetrieval", "true");
    }

    return configuration;
  }

  private void insertObject(Session session, Object object) {
    session.getTransaction().begin();
    session.persist(object);
    session.getTransaction().commit();
  }

  // Directly query the user from the database without caching
  private User queryUserNoCaching(Session session, int id) {
    User user = session.find(User.class, id);
    Hibernate.initialize(user.getTools());
    Hibernate.initialize(user.getSkills());
    return user;
  }

  // Query the user with caching
  private User queryUserWithCaching(Session session, int id) {
    CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
    CriteriaQuery<User> criteriaQuery = criteriaBuilder.createQuery(User.class);
    Root<User> root = criteriaQuery.from(User.class);
    criteriaQuery.select(root).where(criteriaBuilder.equal(root.get("id"), id));

    Query<User> query = session.createQuery(criteriaQuery);
    query.setHint(COMMENT, "CACHE_PARAM(ttl=50s)");
    User user = query.uniqueResult();
    Hibernate.initialize(user.getTools());
    Hibernate.initialize(user.getSkills());
    return user;
  }
}
