/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package integration.container.tests.hibernate;

import static org.hibernate.annotations.QueryHints.COMMENT;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;

import integration.*;
import integration.container.ConnectionStringHelper;
import integration.container.TestDriver;
import integration.container.TestDriverProvider;
import integration.container.TestEnvironment;
import integration.container.condition.*;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.query.Query;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.testcontainers.shaded.org.checkerframework.checker.nullness.qual.Nullable;
import software.amazon.jdbc.plugin.cache.CacheConnection;

@TestMethodOrder(MethodOrderer.MethodName.class)
@EnableOnTestFeature(TestEnvironmentFeatures.VALKEY_CACHE)
@MakeSureFirstInstanceWriter
@Order(24)
public class HibernateCachingTests {
  private static final Logger LOGGER = Logger.getLogger(HibernateCachingTests.class.getName());

  private static boolean isInit = false;

  @BeforeEach
  public void beforeEach() throws SQLException {
    if (isInit) {
      return;
    }

    isInit = true;

    switch (TestEnvironment.getCurrent().getInfo().getRequest().getDatabaseEngine()) {
      case MYSQL:
      case MARIADB:
        try (Connection conn = DriverHelper.getDriverConnection(TestEnvironment.getCurrent().getInfo());
             Statement statement = conn.createStatement()) {
          statement.executeUpdate(
            "create table Author (id integer not null auto_increment, name varchar(255), country varchar(255), primary key (id))");
          statement.executeUpdate(
            "create table Book (id integer not null auto_increment, title varchar(255), year integer, primary key (id))");
          statement.executeUpdate(
            "create table Book_Author (Book_id integer not null, authors_id integer not null, primary key (Book_id, authors_id))");
          statement.executeUpdate(
            "alter table Book_Author add constraint FK_BookAuthor_Author foreign key (authors_id) references Author (id)");
          statement.executeUpdate(
            "alter table Book_Author add constraint FK_BookAuthor_Book foreign key (Book_id) references Book (id)");
          statement.executeUpdate(
            "create table Plane (id integer not null auto_increment, name varchar(255) not null unique, primary key (id))");
        }
        break;
      case PG:
        try (Connection conn = DriverHelper.getDriverConnection(TestEnvironment.getCurrent().getInfo());
             Statement statement = conn.createStatement()) {
          statement.executeUpdate(
            "create table Author (id integer not null generated by default as identity, name varchar(255), country varchar(255), primary key (id))");
          statement.executeUpdate(
            "create table Book (id integer not null generated by default as identity, title varchar(255), year integer, primary key (id))");
          statement.executeUpdate(
            "create table Book_Author (Book_id integer not null, authors_id integer not null)");
          statement.executeUpdate(
            "alter table Book_Author add constraint FK_BookAuthor_Author foreign key (authors_id) references Author (id)");
          statement.executeUpdate(
            "alter table Book_Author add constraint FK_BookAuthor_Book foreign key (Book_id) references Book (id)");
          statement.executeUpdate(
            "create table Plane (id integer not null generated by default as identity, name varchar(255) not null unique, primary key (id))");
        }
        break;
      default:
        throw new UnsupportedOperationException(
          TestEnvironment.getCurrent().getInfo().getRequest().getDatabaseEngine().toString());
    }
  }

  @AfterEach
  public void afterEach() throws Exception {
    // Clear the static connection pool registry
    CacheConnection.clearEndpointPoolRegistry();
  }

  @TestTemplate
  @ExtendWith(TestDriverProvider.class)
  public void testSuccessfulCaching() {

    final Configuration configuration = this.getConfiguration(0, true, null);
    try (StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
        .applySettings(configuration.getProperties())
        .build()) {

      SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);

      try (Session session = sessionFactory.openSession()) {
        // Create authors
        Author orwell = new Author("George Orwell", "United Kingdom");
        this.insertObject(session, orwell);
        Author huxley = new Author("Aldous Huxley", "United Kingdom");
        this.insertObject(session, huxley);
        List<Author> authors = new ArrayList<>();
        authors.add(orwell);

        // Create book
        Book book = new Book("1984", 1949);
        book.setAuthors(authors);
        this.insertObject(session, book);

        // Query without caching
        Book savedBook = queryBookNoCaching(session, book.getId());
        validateBookData(savedBook, "1984", 1949, 1);

        // Query with caching - populate cache
        Book cachedBook = queryBookWithCaching(session, book.getId());
        validateBookData(cachedBook, "1984", 1949, 1);

        // Query again - should come from cache
        Book cachedBook2 = queryBookWithCaching(session, book.getId());
        validateBookData(cachedBook2, "1984", 1949, 1);

        // Insert Plane data
        this.insertObject(session, new Plane("Boeing 787 Dreamliner"));
        this.insertObject(session, new Plane("Boeing 737 MAX"));
        this.insertObject(session, new Plane("Airbus A320"));

        // Named query using annotation-based hint - populate cache
        List<Plane> planes = session.createNamedQuery("Plane.findAll", Plane.class).getResultList();
        assertEquals(3, planes.size());

        // Clear the tables
        session.getTransaction().begin();
        assertEquals(3, session.createQuery("delete from Plane").executeUpdate());
        assertEquals(1, session.createQuery("delete from Book").executeUpdate());
        assertEquals(2, session.createQuery("delete from Author").executeUpdate());
        session.getTransaction().commit();

        // Fetch from cache after deletion
        Book cachedBook3 = queryBookWithCaching(session, book.getId());
        validateBookData(cachedBook3, "1984", 1949, 1);

        List<Plane> planes2 = session.createNamedQuery("Plane.findAll", Plane.class).getResultList();
        assertEquals(3, planes2.size());

        session.clear();
      }
    }
  }

  @TestTemplate
  @ExtendWith(TestDriverProvider.class)
  public void testWrongAuthFallsBackToDatabase() {
    final Configuration configuration = this.getConfiguration(0, true, "wrong-password");

    try (StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
        .applySettings(configuration.getProperties())
        .build()) {

      SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);

      try (Session session = sessionFactory.openSession()) {
        Author author = new Author("J.K. Rowling", "United Kingdom");
        List<Author> authorList = new ArrayList<>();
        authorList.add(author);
        this.insertObject(session, author);
        Book book = new Book("Harry Potter", 1997);
        book.setAuthors(authorList);
        this.insertObject(session, book);

        // Query with wrong credentials - should fall back to database
        Book result1 = queryBookWithCaching(session, book.getId());
        validateBookData(result1, "Harry Potter", 1997, 1);

        // Query again - should still hit database (not cache)
        Book result2 = queryBookWithCaching(session, book.getId());
        validateBookData(result2, "Harry Potter", 1997, 1);

        // Clear the tables
        session.getTransaction().begin();
        assertEquals(1, session.createQuery("delete from Book").executeUpdate());
        assertEquals(1, session.createQuery("delete from Author").executeUpdate());
        session.getTransaction().commit();

        // Query after deletion - should return null (proves cache wasn't used)
        Book result3 = queryBookWithCaching(session, book.getId());
        assertNull(result3);
      }
    }
  }

  @TestTemplate
  @ExtendWith(TestDriverProvider.class)
  public void testNoAuthConnection() {
    // Use the second Valkey instance (no-auth)
    List<TestInstanceInfo> cacheInstances = TestEnvironment.getCurrent().getInfo().getValkeyServerInfo().getInstances();
    if (cacheInstances.size() < 2) {
      return; // Skip test if no-auth instance not available
    }

    // Use no-auth instance (index 1), no credentials
    final Configuration configuration = getConfiguration(1, false, null);

    try (StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
        .applySettings(configuration.getProperties())
        .build()) {

      SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);

      try (Session session = sessionFactory.openSession()) {
        // Create author and book
        Author author = new Author("Isaac Asimov", "United States");
        List<Author> authorList = new ArrayList<>();
        authorList.add(author);
        this.insertObject(session, author);
        Book book = new Book("Foundation", 1951);
        book.setAuthors(authorList);
        this.insertObject(session, book);

        // First query with caching - should work without auth
        Book result1 = queryBookWithCaching(session, book.getId());
        validateBookData(result1, "Foundation", 1951, 1);

        // Second query - should come from cache
        Book result2 = queryBookWithCaching(session, book.getId());
        validateBookData(result2, "Foundation", 1951, 1);

        // Clear the tables
        session.getTransaction().begin();
        assertEquals(1, session.createQuery("delete from Book").executeUpdate());
        assertEquals(1, session.createQuery("delete from Author").executeUpdate());
        session.getTransaction().commit();

        // Query after deletion - should return cached data (proves cache was used)
        Book result3 = queryBookWithCaching(session, book.getId());
        validateBookData(result3, "Foundation", 1951, 1);
      }
    }
  }

  @TestTemplate
  @ExtendWith(TestDriverProvider.class)
  public void testMultipleQueriesUseDifferentCacheKeys() {
    final Configuration configuration = this.getConfiguration(0, true, null);
    try (StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
        .applySettings(configuration.getProperties())
        .build()) {

      SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);

      try (Session session = sessionFactory.openSession()) {
        // Create two different authors
        Author orwell = new Author("George Orwell", "United Kingdom");
        this.insertObject(session, orwell);
        Author huxley = new Author("Aldous Huxley", "United Kingdom");
        this.insertObject(session, huxley);

        // Create two different books
        List<Author> orwellList = new ArrayList<>();
        orwellList.add(orwell);
        Book book1984 = new Book("1984", 1949);
        book1984.setAuthors(orwellList);
        this.insertObject(session, book1984);

        List<Author> huxleyList = new ArrayList<>();
        huxleyList.add(huxley);
        Book bookBraveNewWorld = new Book("Brave New World", 1932);
        bookBraveNewWorld.setAuthors(huxleyList);
        this.insertObject(session, bookBraveNewWorld);

        // Cache both books with different IDs
        Book cachedBook1 = queryBookWithCaching(session, book1984.getId());
        validateBookData(cachedBook1, "1984", 1949, 1);

        Book cachedBook2 = queryBookWithCaching(session, bookBraveNewWorld.getId());
        validateBookData(cachedBook2, "Brave New World", 1932, 1);

        // Delete both books from database
        session.getTransaction().begin();
        assertEquals(2, session.createQuery("delete from Book").executeUpdate());
        assertEquals(2, session.createQuery("delete from Author").executeUpdate());
        session.getTransaction().commit();

        // Should come from cache with different keys
        Book cachedBook1AfterDelete = queryBookWithCaching(session, book1984.getId());
        validateBookData(cachedBook1AfterDelete, "1984", 1949, 1);

        Book cachedBook2AfterDelete = queryBookWithCaching(session, bookBraveNewWorld.getId());
        validateBookData(cachedBook2AfterDelete, "Brave New World", 1932, 1);

        session.clear();
      }
    }
  }

  private void validateBookData(Book book, String title, int year, int authorCount) {
    assertNotNull(book);
    assertEquals(title, book.getTitle());
    assertEquals(year, book.getYear());
    assertEquals(authorCount, book.getAuthors().size());
  }

  private Book queryBookNoCaching(Session session, int id) {
    Book book = session.find(Book.class, id);
    if (book != null) {
      Hibernate.initialize(book.getAuthors());
    }
    return book;
  }

  private Book queryBookWithCaching(Session session, int id) {
    CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
    CriteriaQuery<Book> criteriaQuery = criteriaBuilder.createQuery(Book.class);
    Root<Book> root = criteriaQuery.from(Book.class);
    criteriaQuery.select(root).where(criteriaBuilder.equal(root.get("id"), id));

    Query<Book> query = session.createQuery(criteriaQuery);
    query.setHint(COMMENT, "CACHE_PARAM(ttl=50s)");
    Book book = query.uniqueResult();
    if (book != null) {
      Hibernate.initialize(book.getAuthors());
    }
    return book;
  }

  private Configuration getConfiguration(int cacheInstanceIndex, boolean includeCredentials, @Nullable String overridePassword) {
    String url = ConnectionStringHelper.getWrapperUrl();
    LOGGER.finest("Connecting to " + url);

    final Configuration configuration = new Configuration();
    configuration.addAnnotatedClass(Book.class);
    configuration.addAnnotatedClass(Author.class);
    configuration.addAnnotatedClass(Plane.class);

    DatabaseEngine databaseEngine = TestEnvironment.getCurrent().getInfo().getRequest().getDatabaseEngine();

    switch (databaseEngine) {
      case PG:
        configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");
        break;
      case MYSQL:
        configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect");
        break;
      case MARIADB:
        configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.MariaDBDialect");
        break;
      default:
        throw new UnsupportedOperationException(databaseEngine.toString());
    }

    configuration.setProperty("hibernate.connection.driver_class", "software.amazon.jdbc.Driver");

    configuration.setProperty("hibernate.show_sql", "true");
    configuration.setProperty("hibernate.format_sql", "true");
    configuration.setProperty("hibernate.hbm2ddl.auto", "none");
    configuration.setProperty("hibernate.connection.url", url);
    configuration.setProperty("hibernate.connection.username",
        TestEnvironment.getCurrent().getInfo().getProxyDatabaseInfo().getUsername());
    configuration.setProperty("hibernate.connection.password",
        TestEnvironment.getCurrent().getInfo().getProxyDatabaseInfo().getPassword());
    configuration.setProperty("hibernate.connection.pool_size", "1");

    // Additional Wrapper driver properties
    configuration.setProperty("hibernate.connection.connectTimeout", "10000");
    configuration.setProperty("hibernate.connection.socketTimeout", "10000");
    configuration.setProperty("hibernate.connection.enableTelemetry", "false");
    configuration.setProperty("hibernate.connection.tcpKeepAlive", "true");

    // Fetch the cache server information
    List<TestInstanceInfo> cacheInstances = TestEnvironment.getCurrent().getInfo().getValkeyServerInfo().getInstances();
    final String cacheEndpoint = cacheInstances.get(cacheInstanceIndex).getHost() + ":" + cacheInstances.get(cacheInstanceIndex).getPort();

    // Caching enablement and configuration
    configuration.setProperty("hibernate.use_sql_comments", "true");
    configuration.setProperty("hibernate.connection.wrapperPlugins", "dataRemoteCache");
    configuration.setProperty("hibernate.connection.cacheEndpointAddrRw", cacheEndpoint);
    configuration.setProperty("hibernate.connection.cacheUseSSL", "false");

    // Only set credentials if requested (for auth-enabled instance)
    if (includeCredentials) {
      configuration.setProperty("hibernate.connection.cacheUsername",
          TestEnvironment.getCurrent().getInfo().getValkeyServerUsername());
      if (overridePassword != null) {
        configuration.setProperty("hibernate.connection.cachePassword", overridePassword);
      } else {
        configuration.setProperty("hibernate.connection.cachePassword",
            TestEnvironment.getCurrent().getInfo().getValkeyServerPassword());
      }
    }

    if (TestEnvironment.getCurrent().getCurrentDriver() == TestDriver.MARIADB) {
      // This property is sometimes required when using the mariadb driver against multi-az mysql version 8.4, or you
      // will get the error "RSA public key is not available client side" when connecting. The mariadb driver may not
      // fully support mysql 8.4's SSL mechanisms, which is why this property is only required for newer mysql versions.
      configuration.setProperty("hibernate.connection.allowPublicKeyRetrieval", "true");
    }

    return configuration;
  }

  private void insertObject(Session session, Object object) {
    session.getTransaction().begin();
    session.persist(object);
    session.getTransaction().commit();
  }
}
